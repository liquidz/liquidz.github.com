<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom"><title>(code "liquidz.uo")</title><link href="http://liquidz.github.io/atom.xml" rel="self" /><link href="http://liquidz.github.io" /><updated></updated><id>http://liquidz.github.io</id><author><name>@uochan</name></author><entry><title>Light Tableプラグインでのnode.jsモジュールの使い方メモ</title><link>http://liquidz.github.io/2014/01/light-table-require-nodejs-module.html</link><updated>2014-01-19T00:00:00</updated><id>http://liquidz.github.io/2014/01/light-table-require-nodejs-module.html</id><content type="html">&lt;p class=&quot;paragraph&quot;&gt;個人用メモ。今回は &lt;a href=&quot;http://momentjs.com/&quot;&gt;moment.js&lt;/a&gt; を使う方法。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2014/01/20: node.jsのpath.joinではなくlt.objs.files/joinを使うよう修正&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2014/01/24: lt.objs.plugins/find-plugin の補足を追加&lt;/strong&gt;&lt;/p&gt;&lt;h2 id=&quot;G__1686&quot;&gt;&lt;span&gt;p&lt;/span&gt;ackage.json の用意&lt;a class=&quot;dagger&quot; href=&quot;#G__1686&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h2&gt;&lt;p class=&quot;paragraph&quot;&gt;project.clj, plugin.json と同じディレクトリに作成する&lt;/p&gt;&lt;pre class=&quot;prettyprint&quot;&gt;npm init
vim package.json&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;moment.js を dependencies に追加&lt;/p&gt;&lt;pre class=&quot;prettyprint&quot;&gt;&amp;quot;dependencies&amp;quot;: {
    &amp;quot;moment&amp;quot;: &amp;quot;~2.5.0&amp;quot;
}&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;moment.js をインストール&lt;/p&gt;&lt;pre class=&quot;prettyprint&quot;&gt;npm install&lt;/pre&gt;&lt;h2 id=&quot;G__1687&quot;&gt;&lt;span&gt;プ&lt;/span&gt;ラグイン内で moment.js を利用する&lt;a class=&quot;dagger&quot; href=&quot;#G__1687&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h2&gt;&lt;pre class=&quot;prettyprint lang-clj&quot;&gt;(ns lt.plugins.foo
  (:require
    [clojure.string :as string]
    [lt.objs.files :as files]
    [lt.objs.plugins :as plugins]))

;; プラグイン名。あとで使う
(def PLUGIN_NAME &amp;quot;foo&amp;quot;)

;; ユーザプラグインのディレクトリは lt.objs.plugins/user_plugins_dir から取得
;; TODO: PLUGIN_NAME を使わないようにしたい。。
(def moment
  (js/require
    (files/join plugins/user_plugins_dir PLUGIN_NAME &amp;quot;node_modules&amp;quot; &amp;quot;moment&amp;quot;)))

(defn foo-task
  []
  (println (.format (moment) &amp;quot;YYYY-MM-DD HH:mm:ss&amp;quot;)))&lt;/pre&gt;&lt;h2 id=&quot;G__1688&quot;&gt;&lt;span&gt;課&lt;/span&gt;題&lt;a class=&quot;dagger&quot; href=&quot;#G__1688&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h2&gt;&lt;p class=&quot;paragraph&quot;&gt;ソース内のコメントにも書いた通り、ユーザプラグインのディレクトリまでは取れるけれども、作っているプラグインのディレクトリまでは取得できないため、プラグイン名を定数としてもたざるを得ず気持ち悪いこと。良い解決策を知っている方がいれば教えていただけると助かります！&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;[2014.01.24 追記] Light Table 0.6.1 からは lt.objs.plugins/find-plugin が追加され、プラグイン名を渡せばプラグインのディレクトリが取れるようになりました。結局プラグイン名は必要ですが。。&lt;/p&gt;&lt;pre class=&quot;prettyprint lang-clj&quot;&gt;(plugins/find-plugin PLUGIN_NAME) ; =&amp;gt; (files/join plugins/user_plugins_dir PLUGIN_NAME) と同じ&lt;/pre&gt;&lt;h2 id=&quot;G__1689&quot;&gt;&lt;span&gt;参&lt;/span&gt;考&lt;a class=&quot;dagger&quot; href=&quot;#G__1689&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;https://github.com/joshuafcole/claire&quot;&gt;Claire&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;</content></entry><entry><title>Light Tableの簡単なプラグインを作ってみた</title><link>http://liquidz.github.io/2014/01/light-table-trailing-whitespace.html</link><updated>2014-01-12T00:00:00</updated><id>http://liquidz.github.io/2014/01/light-table-trailing-whitespace.html</id><content type="html">&lt;p class=&quot;paragraph&quot;&gt;&lt;a href=&quot;http://www.lighttable.com/&quot;&gt;Light Table&lt;/a&gt; 0.6.0 からオープンソースになり、さらにプラグインに対応したとのことで今、Light Table 熱がすごいですね。&lt;br /&gt;    プラグインについての詳細なドキュメントはまだ出てないようですが、次々と新しいプラグインが作られているのを見て自分も負けてられないと思い、
    勉強のために既存のプラグインを参考に簡単なプラグインを作ってみました。&lt;/p&gt;&lt;h2 id=&quot;G__1716&quot;&gt;&lt;span&gt;t&lt;/span&gt;railing-whitespace&lt;a class=&quot;dagger&quot; href=&quot;#G__1716&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;https://github.com/liquidz/trailing-whitespace&quot;&gt;https://github.com/liquidz/trailing-whitespace&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p class=&quot;paragraph&quot;&gt;末尾に空白があった場合にそれを見やすく表示してくれるプラグインです。&lt;br /&gt;    元々 Light Table には &lt;code class=&quot;prettyprint&quot;&gt;:lt.objs.editor.file/remove-trailing-whitespace&lt;/code&gt; という設定があり保存時に末尾空白を削除してくれますが、例え保存してもファイルを開き直さない限り末尾空白が残ってしまうので、気付かずに行ごとコピーすると末尾空白も含まれてしまいます。&lt;br /&gt;    そういったことを避けるために、このプラグインを使うと保存前でも末尾空白の存在を把握できるようになります。&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;このプラグインを作るにあたって、Light Table は &lt;a href=&quot;http://codemirror.net/&quot;&gt;CodeMirror&lt;/a&gt; をベースにしているので、CodeMirror のアドオンを移植するのが一番簡単そうと思い、以下のアドオンをベースに選びました。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://codemirror.net/addon/edit/trailingspace.js&quot;&gt;edit/trailingspace.js&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Adds an option showTrailingSpace which, when enabled, adds the CSS class cm-trailingspace to stretches of whitespace at the end of lines. &lt;/p&gt;&lt;/blockquote&gt;&lt;p class=&quot;paragraph&quot;&gt;メインとなる処理はほとんど JS のソースをそのまま ClojureScript に持っていっているだけですが、
    設定の有効・無効の切り替えなど Light Table 固有の箇所は以下のプラグインを参考にしました。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;https://github.com/LightTable/Whitespace&quot;&gt;Whitespace&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p class=&quot;paragraph&quot;&gt;空白を可視化するというシンプルなプラグインでコードも短くわかりやすいです。
    実現したい目的と内容が近いので基本的にはこのプラグインのソースをベースにして作成しました。&lt;br /&gt;    Light Table のプラグインを作ろうと思っている方はこのプラグインか次に紹介するプラグインを最初に参考すると良いと思います。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;https://github.com/LightTable/Declassifier&quot;&gt;Declassifier&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p class=&quot;paragraph&quot;&gt;Light Table のサンプルプラグインです。公式ドキュメントからリンクが貼られているので見ている方も多いかと思います。&lt;br /&gt;    特定の文字列を置き換えるというシンプルなプラグインなので、こちらも読みやすいです。
    これもプラグイン作成の良い教材なので最初に参考にすると良いです。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;https://github.com/joshuafcole/claire&quot;&gt;claire&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p class=&quot;paragraph&quot;&gt;ファイル検索のプラグインです。
    0.6.0 が出てから数日で開発されたプラグインであまりの仕事の早さに驚きました。&lt;br /&gt;    処理で参考にした部分はない(そこまで読めてない)のですが、プラグインの中にCSSファイルをどう取り込むかというところで
    プラグインの behaviors ファイルの書き方を参考にしました。&lt;/p&gt;&lt;h2 id=&quot;G__1717&quot;&gt;&lt;span&gt;最&lt;/span&gt;後に&lt;a class=&quot;dagger&quot; href=&quot;#G__1717&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h2&gt;&lt;p class=&quot;paragraph&quot;&gt;今回は既存のアドオンの移植だけなのでまだまだですが、これを機に他プラグインも研究してより便利なプラグインを作りたいなと思っています。
    そしていつかは Vimmer を卒gy ゲフンゲフン&lt;/p&gt;</content></entry><entry><title>Mac上のVimを最新にした際のメモ(LuaJIT対応)</title><link>http://liquidz.github.io/2013/12/vim.html</link><updated>2013-12-22T00:00:00</updated><id>http://liquidz.github.io/2013/12/vim.html</id><content type="html">&lt;p class=&quot;paragraph&quot;&gt;Mac上でVimをソースからインストールしたことがなかったので、ソースビルドするついでにLua対応した際のメモです。&lt;/p&gt;&lt;h2 id=&quot;G__1744&quot;&gt;&lt;span&gt;参&lt;/span&gt;考&lt;a class=&quot;dagger&quot; href=&quot;#G__1744&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h2&gt;&lt;p class=&quot;paragraph&quot;&gt;作業する際に参考したページは以下の通りです。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;http://saihoooooooo.hatenablog.com/entry/2013/11/29/152525&quot;&gt;neocompleteを入れてみた作業ログ - Make 鮫 noise&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;http://saihoooooooo.hatenablog.com/entry/2013/12/02/122005&quot;&gt;vimにluajitを対応させてみた作業ログ - Make 鮫 noise&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;http://kazuomabuo.hatenablog.jp/entry/2013/08/21/112226&quot;&gt;Installed Vim7.4 - mabulog&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 id=&quot;G__1745&quot;&gt;&lt;span&gt;必&lt;/span&gt;要なライブラリをインストール&lt;a class=&quot;dagger&quot; href=&quot;#G__1745&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h2&gt;&lt;pre class=&quot;prettyprint&quot;&gt;brew install mercurial
brew install lua&lt;/pre&gt;&lt;h2 id=&quot;G__1746&quot;&gt;&lt;span&gt;L&lt;/span&gt;uaJITをビルド&lt;a class=&quot;dagger&quot; href=&quot;#G__1746&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h2&gt;&lt;pre class=&quot;prettyprint&quot;&gt;cd ~/opt/src
git clone http://luajit.org/git/luajit-2.0.git luajit
cd luajit

make
make install&lt;/pre&gt;&lt;h2 id=&quot;G__1747&quot;&gt;&lt;span&gt;V&lt;/span&gt;imをビルド&lt;a class=&quot;dagger&quot; href=&quot;#G__1747&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h2&gt;&lt;pre class=&quot;prettyprint&quot;&gt;cd ~/opt/src
hg clone https://vim.googlecode.com/hg/ vim
cd vim

./configure --prefix=/usr/local --with-features=huge --enable-multibyte --enable-luainterp --with-luajit --enable-fail-if-missing --with-lua-prefix=/usr/local

make
make install&lt;/pre&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;最後の '--with-lua-prefix' を指定しないとconfigure時に 'configure: error: could not configure lua' が出てしまう&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 id=&quot;G__1748&quot;&gt;&lt;span&gt;余&lt;/span&gt;談: Vim 設定&lt;a class=&quot;dagger&quot; href=&quot;#G__1748&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&quot;G__1749&quot;&gt;&lt;span&gt;N&lt;/span&gt;eoComplete&lt;a class=&quot;dagger&quot; href=&quot;#G__1749&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h3&gt;&lt;p class=&quot;paragraph&quot;&gt;NeoComplete の設定をした際に &lt;code class=&quot;prettyprint&quot;&gt;Another plugin set completefunc! Disabled neocomplete.&lt;/code&gt; というエラーが出たので、.vimrc にて以下を指定して回避。&lt;/p&gt;&lt;pre class=&quot;prettyprint&quot;&gt;let g:neocomplete#force_overwrite_completefunc = 1&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;参考ページ&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;https://github.com/tpope/vim-rails/issues/283&quot;&gt;issue with neocomplete plugin · Issue #283 · tpope/vim-rails&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;</content></entry><entry><title>Clojureのテンプレートエンジン「cuma」を作ったクマー</title><link>http://liquidz.github.io/2013/04/cuma.html</link><updated>2013-04-14T00:00:00</updated><id>http://liquidz.github.io/2013/04/cuma.html</id><content type="html">&lt;p class=&quot;paragraph&quot;&gt;Clojureでシンプルなテンプレートエンジンを作りました&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;cuma: Extensible micro template engine for Clojure&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/liquidz/cuma&quot;&gt;https://github.com/liquidz/cuma&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&quot;G__1776&quot;&gt;&lt;span&gt;動&lt;/span&gt;機&lt;a class=&quot;dagger&quot; href=&quot;#G__1776&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h2&gt;&lt;p class=&quot;paragraph&quot;&gt;もともと、&lt;a href=&quot;https://gihub.com/liquidz/misaki/&quot;&gt;misaki&lt;/a&gt;などでは&lt;a href=&quot;https://github.com/fhd/clostache&quot;&gt;clostache&lt;/a&gt;というテンプレートエンジンを使ってました。&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;これは&lt;a href=&quot;http://mustache.github.io/&quot;&gt;mustache&lt;/a&gt;のClojure版で、これはこれでとても素晴らしいものなのですが
   &lt;a href=&quot;https://gihub.com/liquidz/misaki-markdown/&quot;&gt;misaki-markdown&lt;/a&gt; を開発する上で
   以下2つの問題にぶつかりました以下2つの問題にぶつかりました&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;置き換える文字列中にテンプレートの表記があると正しく置き換えられない&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;機能拡張ができない&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p class=&quot;paragraph&quot;&gt;前者については送った&lt;a href=&quot;https://github.com/fhd/clostache/pull/28&quot;&gt;pull-request&lt;/a&gt;がマージされたので解消されていますが、後者についてはそもそもmustacheが &lt;em&gt;Logic-less templates&lt;/em&gt; を謳っているので
   方向性が違うのかと思います。&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;そこでシンプルなフォーマットを保ちつつ、clojureで機能拡張できるものとして&lt;a href=&quot;https://github.com/liquidz/cuma&quot;&gt;cuma&lt;/a&gt;を作りました。&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;なぜ「cuma」なのかというと、別に自分がクマ好きでカバンとか携帯にクマのぬいぐるみを付けてるからとかそういうのではなく '&lt;strong&gt;C&lt;/strong&gt;lo&lt;strong&gt;U&lt;/strong&gt;reのte&lt;strong&gt;M&lt;/strong&gt;pl&lt;strong&gt;A&lt;/strong&gt;te'からテキトーに文字をピックアップしただけです。偶然です。&lt;/p&gt;&lt;h2 id=&quot;G__1777&quot;&gt;&lt;span&gt;特&lt;/span&gt;徴&lt;a class=&quot;dagger&quot; href=&quot;#G__1777&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h2&gt;&lt;p class=&quot;paragraph&quot;&gt;Clostacheと同じことは同じようにできます。インラインでは&lt;code class=&quot;prettyprint&quot;&gt;$(...)&lt;/code&gt;、複数行にまたがるものは&lt;code class=&quot;prettyprint&quot;&gt;@(...) ... @(/...)&lt;/code&gt; というフォーマットになっています。他の例は&lt;a href=&quot;https://github.com/liquidz/cuma&quot;&gt;github&lt;/a&gt;のページを参照してください。&lt;/p&gt;&lt;pre class=&quot;prettyprint lang-clj&quot;&gt;(render &amp;quot;$(x)&amp;quot; {:x &amp;quot;hello&amp;quot;})
;=&amp;gt; hello

(render &amp;quot;$(escape x)&amp;quot; {:x &amp;quot;&amp;lt;h1&amp;gt;hello&amp;lt;/h1&amp;gt;&amp;quot;})
;=&amp;gt; &amp;amp;lt;h1&amp;amp;gt;hello&amp;amp;lt;/h1&amp;amp;gt;

(render &amp;quot;@(if flag) hello @(/if)&amp;quot; {:flag true})
;=&amp;gt; hello

(render &amp;quot;@(for arr) $(.) @(/for)&amp;quot; {:arr [1 2 3]})
;=&amp;gt; 1 2 3&lt;/pre&gt;&lt;h3 id=&quot;G__1778&quot;&gt;&lt;span&gt;拡&lt;/span&gt;張機能&lt;a class=&quot;dagger&quot; href=&quot;#G__1778&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h3&gt;&lt;p class=&quot;paragraph&quot;&gt;cumaでは上記フォーマットを保ったまま機能拡張することができます。
   具体的には上記の &lt;code class=&quot;prettyprint&quot;&gt;escape&lt;/code&gt;, &lt;code class=&quot;prettyprint&quot;&gt;if&lt;/code&gt;, &lt;code class=&quot;prettyprint&quot;&gt;for&lt;/code&gt; にあたるものを自分で作ることができますし、
   &lt;code class=&quot;prettyprint&quot;&gt;escape&lt;/code&gt;, &lt;code class=&quot;prettyprint&quot;&gt;if&lt;/code&gt;, &lt;code class=&quot;prettyprint&quot;&gt;for&lt;/code&gt; 自体も本体に組み込まれていますが拡張機能として実装されています。&lt;/p&gt;&lt;a href=&quot;https://github.com/liquidz/cuma/blob/master/src/cuma/extension/core.clj&quot;&gt;https://github.com/liquidz/cuma/blob/master/src/cuma/extension/core.clj&lt;/a&gt;&lt;p class=&quot;paragraph&quot;&gt;cumaでは実行時に &lt;code class=&quot;prettyprint&quot;&gt;cuma.extension.*&lt;/code&gt; という名前空間を検索し、その中のpublicな関数を
   拡張機能としてロードし、テンプレート内で使うことができます。&lt;/p&gt;&lt;pre class=&quot;prettyprint lang-clj&quot;&gt;(ns cuma.extension.hello)

(defn hello [data s]
  (str &amp;quot;hello &amp;quot; s))&lt;/pre&gt;&lt;pre class=&quot;prettyprint lang-clj&quot;&gt;(render &amp;quot;$(hello x)&amp;quot; {:x &amp;quot;world&amp;quot;})
;=&amp;gt; hello world&lt;/pre&gt;&lt;h3 id=&quot;G__1779&quot;&gt;&lt;span&gt;パ&lt;/span&gt;フォーマンス&lt;a class=&quot;dagger&quot; href=&quot;#G__1779&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h3&gt;&lt;p class=&quot;paragraph&quot;&gt;シンプルなテンプレートなのに動作が遅かったら論外かと思います。cumaでは、misaki, misaki-markdownで使っているclostacheをcumaに移行することを考え、clostacheより高速に動作するようにしています。&lt;/p&gt;&lt;img alt=&quot;&quot; src=&quot;/img/post/2013-04-14/cuma_performance.png&quot; /&gt;&lt;p class=&quot;paragraph&quot;&gt;なお計測に使ったコードは&lt;a href=&quot;https://gist.github.com/liquidz/5381090&quot;&gt;gist&lt;/a&gt;に貼り付けておきました。正確でない点があればご指摘いただければと思います。&lt;/p&gt;&lt;h2 id=&quot;G__1780&quot;&gt;&lt;span&gt;最&lt;/span&gt;後に&lt;a class=&quot;dagger&quot; href=&quot;#G__1780&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h2&gt;&lt;p class=&quot;paragraph&quot;&gt;自分用に作ったので小規模向けではありますが、フォーマットはシンプル、かつ拡張機能による柔軟性を意識して作ったので、そこそこ使いやすいのではないかなと思っています。
   ご意見、要望などあれば&lt;a href=&quot;https://github.com/liquidz/cuma&quot;&gt;github&lt;/a&gt;のissueなりtwitterなりでご連絡ください（・(ｪ)・）&lt;/p&gt;</content></entry><entry><title>ロゴのSVG対応</title><link>http://liquidz.github.io/2013/03/svg-logo.html</link><updated>2013-03-31T00:00:00</updated><id>http://liquidz.github.io/2013/03/svg-logo.html</id><content type="html">&lt;p class=&quot;paragraph&quot;&gt;MacBook Pro Retinaディスプレイモデルの13インチを買って「綺麗すぐる！」とはしゃいでいたのは良いのですが、今までに作ったロゴの汚さが目立ってしまったので、PNGからSVGに画像を変更する手順などメモ代わりにまとめておきます。&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;ひとまず最近一番いじっている&lt;a href=&quot;https://github.com/liquidz/misaki/&quot;&gt;misaki&lt;/a&gt;のロゴが
   Retinaディスプレイで見るとドットが目立って汚らしいのでSVGにしました。&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;/img/logo.png&quot; /&gt;&amp;nbsp;&lt;- PNG&amp;nbsp;|&amp;nbsp;SVG -&gt;&amp;nbsp;&lt;img alt=&quot;&quot; src=&quot;/img/logo.svg&quot; /&gt;&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;元々ロゴは&lt;a href=&quot;http://inkscape.org/&quot;&gt;Inkscape&lt;/a&gt;で作っていたので変更は楽でしたが、PlainなSVGだと&lt;strong&gt;44KB&lt;/strong&gt;とかなりファイルサイズが大きくなってしまったので、以下の手順で最適化されたSVGにしました。これで&lt;strong&gt;5KB&lt;/strong&gt;までサイズを減らすことができます。元PNGが6KBなので1KB減っちゃいました。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;em&gt;Save as...&lt;/em&gt; から名前をつけて保存&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;ファイル形式で &lt;em&gt;Optimized SVG&lt;/em&gt; を選択して保存&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;em&gt;Optimized SVG Output&lt;/em&gt; というダイアログが出るので以下の設定で出力&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p class=&quot;paragraph&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;/img/post/2013-03-31/inkscape.png&quot; style=&quot;width: 500px; height: 438px;&quot; /&gt;&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;なおOptimized SVGを出力する際に[lxml]()ライブラリがインストールされていないと怒られるので、
   以下を参考にインストールしました。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;install lxml in mac 10.7&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://blog.jianhuashao.com/2012/07/install-lxml-in-mac-107.html&quot;&gt;http://blog.jianhuashao.com/2012/07/install-lxml-in-mac-107.html&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p class=&quot;paragraph&quot;&gt;MBP Retina(OS X 10.8.3)で試した限りでは &lt;strong&gt;2. brew install libxlst&lt;/strong&gt; は不要でした。&lt;/p&gt;&lt;h2 id=&quot;G__1807&quot;&gt;&lt;span&gt;最&lt;/span&gt;後に&lt;a class=&quot;dagger&quot; href=&quot;#G__1807&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h2&gt;&lt;p class=&quot;paragraph&quot;&gt;SVG使っているところってほとんど見たことがないですが、
   ロゴがRetinaディスプレイで拡大しても綺麗に見えるのはなかなか気持ちいいです。
   広まるかどうかはともかく大体のブラウザで対応しているらしいので
   使ってみるのもいいかもしれません。&lt;/p&gt;</content></entry><entry><title>misaki 0.2.6-beta リリースしますた</title><link>http://liquidz.github.io/2013/02/misaki-0.2.6-beta.html</link><updated>2013-02-16T00:00:00</updated><id>http://liquidz.github.io/2013/02/misaki-0.2.6-beta.html</id><content type="html">&lt;p class=&quot;paragraph&quot;&gt;&lt;a href=&quot;https://github.com/liquidz/misaki/tree/0.2.6-beta&quot;&gt;misaki 0.2.6-beta&lt;/a&gt; をリリースしました。
   変更内容は大してないので、詳細は&lt;a href=&quot;http://liquidz.github.com/misaki/toc/99-change-log.html&quot;&gt;こちら&lt;/a&gt;を見ていただきたいですが
   今回は特に大きな変更点であるページネーションについて簡単に説明します。&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;今まではトップページに出すポスト一覧は&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;全件を表示する&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;件数を限定して表示する&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p class=&quot;paragraph&quot;&gt;のいずれかしか選択できませんでした。&lt;br /&gt;   ページネーションに対応することで普通のブログのように
   一定のポスト数毎にトップページをページ分けさせることができます。&lt;/p&gt;&lt;h2 id=&quot;G__1834&quot;&gt;&lt;span&gt;設&lt;/span&gt;定方法&lt;a class=&quot;dagger&quot; href=&quot;#G__1834&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h2&gt;&lt;p class=&quot;paragraph&quot;&gt;_config.cljで以下を定義してください。 ※2013/03/07修正&lt;/p&gt;&lt;pre class=&quot;prettyprint lang-clj&quot;&gt;{
 ;; 1ページあたりのポスト数
 ;;    デフォルト値: nil (ページネーション無効)
 :posts-per-page 10

 ;; 2ページ目以降のページ分けされたトップページのファイル名フォーマット
 ;;   デフォルト値: &amp;quot;page{{page}}/{{filename}}&amp;quot;
 ;;   利用可能な変数:
 ;;     @page    : ページ番号(1..N)
 ;;     @filename: ファイル名
 ;;     @name    : 拡張子抜きのファイル名
 ;;     @ext     : 拡張子
 :page-filename-format &amp;quot;page{{page}}/{{filename}}&amp;quot;
 }&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;次にトップページ(index.html.clj)では以下のように記述します。&lt;/p&gt;&lt;pre class=&quot;prettyprint lang-clj&quot;&gt;; ポスト一覧は今まで通りの記述でおｋ
(post-list)

; 前のページ、次のページへのリンク作成
(prev-next-page-link)

;; リンクのデザインをカスタマイズしたい場合には
;; `site`変数からアクセスできるので以下の記述でもおｋ
(if-let [url (:prev-page site)]
  (link &amp;quot;前のページ&amp;quot; url))

(if-let [url (:next-page site)]
  (link &amp;quot;次のページ&amp;quot; url))&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;より詳細な内容については&lt;a href=&quot;http://liquidz.github.com/misaki/toc/08-pagination.html&quot;&gt;ドキュメント&lt;/a&gt;を参照していただければと思います。&lt;/p&gt;&lt;h2 id=&quot;G__1835&quot;&gt;&lt;span&gt;最&lt;/span&gt;後に&lt;a class=&quot;dagger&quot; href=&quot;#G__1835&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h2&gt;&lt;p class=&quot;paragraph&quot;&gt;ページネーションについてはポスト毎にページ分けされることを
   テンプレート内でほとんど意識しなくてもいいような作りにしているつもりです。&lt;br /&gt;   また今回は&lt;code class=&quot;prettyprint&quot;&gt;default&lt;/code&gt;コンパイラで独自のソートがある関係でソース修正が多かったですが
   外部コンパイラでは特別な修正なく対応できるような作りにもしているので
   misakiコンパイラを開発する側にも恩恵は大きいのかなと思っています。&lt;br /&gt;   バグなどあれば&lt;a href=&quot;http://twitter.com/uochan&quot;&gt;uochan&lt;/a&gt;までご連絡ください！&lt;/p&gt;</content></entry><entry><title>外部S式リード時のエラー行取得</title><link>http://liquidz.github.io/2012/07/detailed-read-error.html</link><updated>2012-07-22T00:00:00</updated><id>http://liquidz.github.io/2012/07/detailed-read-error.html</id><content type="html">&lt;p class=&quot;paragraph&quot;&gt;&lt;a href=&quot;https://github.com/liquidz/misaki&quot;&gt;misaki&lt;/a&gt;ではプロジェクト外の*.cljファイルをリードしてHTMLに変換しているのですが、
   そのcljファイルにエラーがあったとしても今まではmisaki内の評価関数内のエラーとして
   例外が発生してしまって、具体的なエラー箇所がぱっとわかる状態ではありませんでした。&lt;/p&gt;&lt;h2 id=&quot;G__1862&quot;&gt;&lt;span&gt;解&lt;/span&gt;決策&lt;a class=&quot;dagger&quot; href=&quot;#G__1862&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h2&gt;&lt;p class=&quot;paragraph&quot;&gt;これを解決するために&lt;code class=&quot;prettyprint&quot;&gt;clojure.core/read&lt;/code&gt;で使っている&lt;code class=&quot;prettyprint&quot;&gt;java.io.PushbackReader&lt;/code&gt;を
   プロキシする形で行数をカウントするようにしてみました。&lt;/p&gt;&lt;pre class=&quot;prettyprint lang-clj&quot;&gt;(defn create-pushback-reader-with-line [in]
  (let [line-num (atom 1)]
    (proxy [PushbackReader IDeref] [in]
      (read [] (let [c (proxy-super read)]
                 (if (and (not= -1 c) (= \newline (char c)))
                   (swap! line-num inc))
                 c))
      (deref [] @line-num))))&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;readをオーバーライドして改行があった場合に&lt;code class=&quot;prettyprint&quot;&gt;line-num&lt;/code&gt;をインクリメントしているだけです。
   &lt;code class=&quot;prettyprint&quot;&gt;clojure.lang.IDeref&lt;/code&gt;を継承しているのは&lt;code class=&quot;prettyprint&quot;&gt;deref&lt;/code&gt;でカウントした行数を取得するためです。
   (&lt;code class=&quot;prettyprint&quot;&gt;deref&lt;/code&gt;を選んだのはなんとなくアクセスが楽だったので)&lt;/p&gt;&lt;pre class=&quot;prettyprint lang-clj&quot;&gt;(require '[clojure.java.io :as io])

(let [r   (io/reader &amp;quot;file-path.clj&amp;quot;)
      pbr (create-pushback-reader-with-line r)]
  ; 通常のread
  (println (.read pbr))
  ; 行数を取得
  (println @pbr))&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;これで各S式がファイルのどの行数に書かれているかをリード時に把握できようになったので
   あとは以下のように&lt;code class=&quot;prettyprint&quot;&gt;clojure.core/read&lt;/code&gt;のエラー時に行番号を利用するだけです。&lt;/p&gt;&lt;pre class=&quot;prettyprint lang-clj&quot;&gt;(let [file-path &amp;quot;foo.clj&amp;quot;
      pbr       (create-pushback-reader-with-line (io/reader file-path))
      line-num  @pbr]
  (try
    (read pbr)
    (catch Exception ex
      (println &amp;quot;エラー箇所は&amp;quot; file-path &amp;quot;の&amp;quot; line-num &amp;quot;行目です！！&amp;quot;))))&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;上記の例は実際にはEOFまでループしなければ意味がないのですが、
   そこまで書くと肝心の部分が見づらくなるので省略しました。&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;なおあくまでもリード時の処理だけなので、評価時のエラー(例えば未定義変数へのアクセス)は
   評価関数内のエラーとして扱われます。&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;また私が他の方法を知らないのでこういった方法で対応しましたが、
   もし他にスマートな方法があれば是非教えてください！&lt;/p&gt;&lt;h2 id=&quot;G__1863&quot;&gt;&lt;span&gt;最&lt;/span&gt;後に&lt;a class=&quot;dagger&quot; href=&quot;#G__1863&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h2&gt;&lt;p class=&quot;paragraph&quot;&gt;misakiの&lt;a href=&quot;https://github.com/liquidz/misaki/tree/dev&quot;&gt;devブランチ&lt;/a&gt;には上記対応を反映済みなので、具体的にエラーにどう反映させているかなどは
   devブランチの&lt;a href=&quot;https://github.com/liquidz/misaki/blob/dev/src/misaki/reader.clj&quot;&gt;src/misaki/reader.clj&lt;/a&gt;をご参照ください。&lt;/p&gt;</content></entry><entry><title>Clojureでブログ生成: misakiのベータ版公開</title><link>http://liquidz.github.io/2012/07/misaki-beta.html</link><updated>2012-07-16T00:00:00</updated><id>http://liquidz.github.io/2012/07/misaki-beta.html</id><content type="html">&lt;p class=&quot;paragraph&quot;&gt;実際の公開からちょっと間空いてしまいましたが、
   &lt;a href=&quot;https://github.com/liquidz/misaki&quot;&gt;misaki&lt;/a&gt;のベータ版を公開しました。&lt;/p&gt;&lt;h2 id=&quot;G__1890&quot;&gt;&lt;span&gt;m&lt;/span&gt;isakiとは?&lt;a class=&quot;dagger&quot; href=&quot;#G__1890&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h2&gt;&lt;p class=&quot;paragraph&quot;&gt;rubyの&lt;a href=&quot;https://github.com/mojombo/jekyll&quot;&gt;Jekyll&lt;/a&gt;を参考にClojureで作った静的サイトジェネレータです。当ブログもmisakiで生成していて、
   misaki自体の&lt;a href=&quot;http://liquidz.github.com/misaki/&quot;&gt;ドキュメント&lt;/a&gt;もmisakiで管理・生成しています。&lt;/p&gt;&lt;h2 id=&quot;G__1891&quot;&gt;&lt;span&gt;何&lt;/span&gt;が新しいの?&lt;a class=&quot;dagger&quot; href=&quot;#G__1891&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h2&gt;&lt;p class=&quot;paragraph&quot;&gt;ベータ版で追加した主な機能は以下の通りです。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;Clojurescriptへの対応&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;出力のカスタマイズ&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;ビルトイン関数の拡充&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;スマホ対応&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 id=&quot;G__1892&quot;&gt;&lt;span&gt;C&lt;/span&gt;lojurescript対応&lt;a class=&quot;dagger&quot; href=&quot;#G__1892&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h2&gt;&lt;p class=&quot;paragraph&quot;&gt;設定ファイルに定義を追加することでClojurescriptをビルドすることができるようになりました。
   今まではテンプレートをS式で書くだけでしたが、これでJSもS式で書けるようになったので
   また一歩、全部Clojureのターンに近づいた感じです。&lt;/p&gt;&lt;pre class=&quot;prettyprint lang-clj&quot;&gt;;; clojurescript compile options
 ;; src-dir base is `:template-dir`
 ;; output-dir base is `:public-dir`
 :cljs {:src-dir       &amp;quot;cljs&amp;quot;
        :output-to     &amp;quot;js/hello.js&amp;quot;
        :optimizations :whitespace
        :pretty-print true}&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;上記の定義を _config.clj に書く(デフォルトでコメントアウトされています)ことで
   テンプレートディレクトリ(&lt;code class=&quot;prettyprint&quot;&gt;:template-dir&lt;/code&gt;)内の&lt;code class=&quot;prettyprint&quot;&gt;cljs&lt;/code&gt;ディレクトリにあるcljsファイルを
   出力先ディレクトリ(&lt;code class=&quot;prettyprint&quot;&gt;:public-dir&lt;/code&gt;)の&lt;code class=&quot;prettyprint&quot;&gt;js/hello.js&lt;/code&gt;としてビルドします。&lt;/p&gt;&lt;h2 id=&quot;G__1893&quot;&gt;&lt;span&gt;出&lt;/span&gt;力のカスタマイズ&lt;a class=&quot;dagger&quot; href=&quot;#G__1893&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h2&gt;&lt;p class=&quot;paragraph&quot;&gt;Alpha版で指定できたポストファイル名の正規表現と出力ファイル名は
   ブログ生成に重点を置いていたため日付が付くことが前提でカスタマイズとしては微妙な機能でした。&lt;br /&gt;   Beta版では日付への縛りをなくすことでより自由な出力ができるようになっています。
   その良い例がmisakiの&lt;a href=&quot;http://liquidz.github.com/misaki/&quot;&gt;ドキュメント&lt;/a&gt;です。&lt;/p&gt;&lt;pre class=&quot;prettyprint lang-clj&quot;&gt;;; post setting
 ;;   default value: #&amp;quot;(\d{4})[-_](\d{1,2})[-_](\d{1,2})[-_](.+)$&amp;quot;
 :post-filename-regexp #&amp;quot;(\d{4})[-_](\d{1,2})[-_](\d{1,2})[-_](.+)$&amp;quot;
 ;:post-filename-format &amp;quot;{{year}}-{{month}}/{{filename}}&amp;quot;
 :post-filename-format &amp;quot;toc/{{filename}}&amp;quot;

 ;; post sort type (:date :name :title :date-desc :name-desc :title-desc)
 ;;   default value: :date-desc
 :post-sort-type :name&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;ドキュメントの&lt;code class=&quot;prettyprint&quot;&gt;:post-filename-regexp&lt;/code&gt;はデフォルトのままですが、
   実際のポストのファイル名は&lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;double-quote&quot;&gt;&quot;&lt;/span&gt;01-getting-started.html.clj&lt;span class=&quot;double-quote&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;となっており、日付に縛られていないことがわかります。&lt;br /&gt;   なおファイル名の先頭の数字はポストのソート順(&lt;code class=&quot;prettyprint&quot;&gt;:post-sort-type&lt;/code&gt;)で使っているのみで
   この数字も必須というわけではありません。&lt;/p&gt;&lt;h2 id=&quot;G__1894&quot;&gt;&lt;span&gt;ビ&lt;/span&gt;ルトイン関数の拡充&lt;a class=&quot;dagger&quot; href=&quot;#G__1894&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h2&gt;&lt;p class=&quot;paragraph&quot;&gt;Alpha版ではhiccupを使ったS式からHTMLへのコンパイラという意味合いが強かったのですが、
   Beta版ではテンプレートを生成するためのビルトイン関数を(ある程度)充実させました。
   それにより、より容易にサイトを構成することが可能になっています。&lt;br /&gt;   詳細は&lt;a href=&quot;http://liquidz.github.com/misaki/api/uberdoc.html#misaki.html.core&quot;&gt;ビルトイン関数のAPI&lt;/a&gt;を参照してください。&lt;/p&gt;&lt;h2 id=&quot;G__1895&quot;&gt;&lt;span&gt;ス&lt;/span&gt;マホ対応&lt;a class=&quot;dagger&quot; href=&quot;#G__1895&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h2&gt;&lt;p class=&quot;paragraph&quot;&gt;「ビルトイン関数の拡充」にも関係してきますが、ビルトイン関数で提供している
   &lt;code class=&quot;prettyprint&quot;&gt;header&lt;/code&gt;, &lt;code class=&quot;prettyprint&quot;&gt;container&lt;/code&gt;, &lt;code class=&quot;prettyprint&quot;&gt;footer&lt;/code&gt; など共通の機能を使っている場合には
   スマホでもそこまで違和感なく表示できるようにしました。&lt;br /&gt;   なお当ブログはいろいろカスタマイズしてるので、まだスマホ対応ちゃんとしてません。。そのうちします(´・ω・｀)&lt;p class=&quot;paragraph add&quot;&gt;あくまで共通機能を使っている場合のみなので、
         どんな使い方をしてもスマホ対応できるわけではないのでご注意ください。
         また「違和感なく見れる程度」なのでスマホに最適化されているわけでもありません。&lt;/p&gt;&lt;/p&gt;&lt;h2 id=&quot;G__1896&quot;&gt;&lt;span&gt;ど&lt;/span&gt;う使えばいいの?&lt;a class=&quot;dagger&quot; href=&quot;#G__1896&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h2&gt;&lt;p class=&quot;paragraph&quot;&gt;&lt;a href=&quot;http://liquidz.github.com/misaki/&quot;&gt;ドキュメント&lt;/a&gt;、もしくは&lt;a href=&quot;/2012/04/misaki.html&quot;&gt;以前のエントリー&lt;/a&gt;に具体例をまとめているのでそちらを参照してください。&lt;/p&gt;&lt;h2 id=&quot;G__1897&quot;&gt;&lt;span&gt;最&lt;/span&gt;後に&lt;a class=&quot;dagger&quot; href=&quot;#G__1897&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h2&gt;&lt;p class=&quot;paragraph&quot;&gt;ソースは&lt;a href=&quot;https://github.com/liquidz/misaki/&quot;&gt;GitHub&lt;/a&gt;で管理しているので
   動作のおかしい箇所や要望はIssuesに追加してもらえるとありがたいです！&lt;/p&gt;</content></entry><entry><title>Clojure1.4のReader Literalsで遊んでみた</title><link>http://liquidz.github.io/2012/04/reader-literal.html</link><updated>2012-04-16T00:00:00</updated><id>http://liquidz.github.io/2012/04/reader-literal.html</id><content type="html">&lt;p class=&quot;paragraph&quot;&gt;Clojure 1.4が出ました！
   前々から話題になっていたReader Literalsが使えるようになったので
   ちょっと遊んでみました。&lt;/p&gt;&lt;h2 id=&quot;G__1924&quot;&gt;&lt;span&gt;ま&lt;/span&gt;ずは下準備&lt;a class=&quot;dagger&quot; href=&quot;#G__1924&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h2&gt;&lt;p class=&quot;paragraph&quot;&gt;基本は&lt;a href=&quot;https://github.com/clojure/clojure/blob/master/changes.md&quot;&gt;こちら&lt;/a&gt;に書いてある通りです。&lt;/p&gt;&lt;pre class=&quot;prettyprint&quot;&gt;$ lein new myreader
$ cd myreader
$ vi project.clj&lt;/pre&gt;&lt;pre class=&quot;prettyprint lang-clj&quot;&gt;(defproject myreader &amp;quot;1.0.0-SNAPSHOT&amp;quot;
  :description &amp;quot;FIXME: write description&amp;quot;
  :dependencies [[org.clojure/clojure &amp;quot;1.4.0&amp;quot;]]) ; 1.4.0&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;readerの定義は src ディレクトリ直下に &lt;code class=&quot;prettyprint&quot;&gt;data_readers.clj&lt;/code&gt; というファイルを作り、そこに定義します。
   手始めに文字列を大文字に変換するreaderを定義してみましょう。&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;&lt;strong&gt;src/data_readers.clj&lt;/strong&gt;&lt;/p&gt;&lt;pre class=&quot;prettyprint lang-clj&quot;&gt;{
 upper  myreader.core/upper-case
 }&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;&lt;strong&gt;src/myreader/core.clj&lt;/strong&gt;&lt;/p&gt;&lt;pre class=&quot;prettyprint lang-clj&quot;&gt;(ns myreader.core)

(defn upper-case [s]
  `(.toUpperCase s))&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;ここまで書いたらreplで試してみましょう。&lt;/p&gt;&lt;pre class=&quot;prettyprint&quot;&gt;$ lein repl&lt;/pre&gt;&lt;pre class=&quot;prettyprint lang-clj&quot;&gt;#upper&amp;quot;hello, world&amp;quot;
;=&amp;gt; &amp;quot;HELLO, WORLD&amp;quot;&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;なおreaderの定義は &lt;em&gt;data-readers&lt;/em&gt; にbindingすることでも定義できます。ただ当然のことながらbinding後のreadから有効になるので、それ以前のものには適用されません。&lt;/p&gt;&lt;pre class=&quot;prettyprint lang-clj&quot;&gt;(defn upper-case2 [s]
  `(str &amp;quot;_&amp;quot; (.toUpperCase ~s) &amp;quot;_&amp;quot;))
;=&amp;gt; #'fuga.core/upper-case2
(binding [*data-readers* {'upper fuga.core/upper-case2}]
  (println #upper&amp;quot;hello&amp;quot;)
  ;=&amp;gt; HELLO
  (println (eval (read-string &amp;quot;#upper\&amp;quot;hello\&amp;quot;&amp;quot;))))
  ;=&amp;gt; _HELLO_&lt;/pre&gt;&lt;h2 id=&quot;G__1925&quot;&gt;&lt;span&gt;G&lt;/span&gt;aucheのデバッグプリント&lt;a class=&quot;dagger&quot; href=&quot;#G__1925&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h2&gt;&lt;p class=&quot;paragraph&quot;&gt;少し使えそうなものとしてGaucheのデバッグプリント&lt;code class=&quot;prettyprint&quot;&gt;?=&lt;/code&gt;を実装してみましょう。&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;&lt;strong&gt;src/data_readers.clj&lt;/strong&gt;&lt;/p&gt;&lt;pre class=&quot;prettyprint lang-clj&quot;&gt;{
 ?=   myreader.core/debug-print
 }&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;&lt;strong&gt;src/myreader/core.clj&lt;/strong&gt;&lt;/p&gt;&lt;pre class=&quot;prettyprint lang-clj&quot;&gt;(ns myreader.core)

(defn debug-print [x]
  `(let [res# ~x]
     (println &amp;quot;?=&amp;quot; res#)
     res#))&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;こんなものを定義してあげると以下のようなことができます。&lt;/p&gt;&lt;pre class=&quot;prettyprint lang-clj&quot;&gt;(map inc #?=(range 10))
;?= (0 1 2 3 4 5 6 7 8 9)
;=&amp;gt; (1 2 3 4 5 6 7 8 9 10)&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;ここの値がどうなってるか確認したいけど、わざわざletで囲んでprintlnするの面倒！ということは多いと思いますがこれで解決ですね！&lt;/p&gt;&lt;h2 id=&quot;G__1926&quot;&gt;&lt;span&gt;文&lt;/span&gt;字列中の式を展開&lt;a class=&quot;dagger&quot; href=&quot;#G__1926&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h2&gt;&lt;p class=&quot;paragraph&quot;&gt;perlの &quot;$var&quot; 然り、rubyの &quot;#{var}&quot; 然り、他言語では文字列中で変数を展開する構文があります。これをClojureで実装してみましょう。&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;今回は文字列中のバッククオートに囲まれた部分を式として評価するように変換します。&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;&lt;strong&gt;src/data_readers.clj&lt;/strong&gt;&lt;/p&gt;&lt;pre class=&quot;prettyprint lang-clj&quot;&gt;{
 str myreader.core/expand-sexp
 }&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;&lt;strong&gt;src/myreader/core.clj&lt;/strong&gt;&lt;/p&gt;&lt;pre class=&quot;prettyprint lang-clj&quot;&gt;(defn expand-sexp [s]
  (let [ls (map-indexed #(if (even? %) %2 (read-string %2))
                        (str/split s #&amp;quot;`&amp;quot;))]
    `(apply str (list ~@ls))))&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;ではreplで試してみましょう。&lt;/p&gt;&lt;pre class=&quot;prettyprint lang-clj&quot;&gt;(def i 100)
;=&amp;gt; #'hoge.core/i
#str&amp;quot;i = `i`&amp;quot;
;=&amp;gt; &amp;quot;i = 100&amp;quot;
#str&amp;quot;(+ 1 2) = `(+ 1 2)`&amp;quot;
;=&amp;gt; &amp;quot;(+ 1 2) = 3&amp;quot;&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;イイネ！&lt;/p&gt;&lt;h2 id=&quot;G__1927&quot;&gt;&lt;span&gt;最&lt;/span&gt;後に&lt;a class=&quot;dagger&quot; href=&quot;#G__1927&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h2&gt;&lt;p class=&quot;paragraph&quot;&gt;使いどころはちゃんと見極めないとですが、可能性がぐんっと広がりますね！
   そんな感じでReader Literalsで遊んでみました。&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;コードは一応&lt;a href=&quot;https://gist.github.com/2399254&quot;&gt;Gist&lt;/a&gt;にも貼っておきます。&lt;/p&gt;</content></entry><entry><title>ブログをJekyllからmisakiに移行したった</title><link>http://liquidz.github.io/2012/04/misaki-blog.html</link><updated>2012-04-10T00:00:00</updated><id>http://liquidz.github.io/2012/04/misaki-blog.html</id><content type="html">&lt;p class=&quot;paragraph&quot;&gt;ちょこちょこ直しながらの作業だったので時間がかかってしまいましたが、
   ブログを&lt;a href=&quot;https://github.com/liquidz/misaki&quot;&gt;misaki&lt;/a&gt;に移行しました。&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;misakiの詳細については&lt;a href=&quot;http://liquidz.github.com/2012/04/misaki.html&quot;&gt;前回のポスト&lt;/a&gt;をご参照ください。&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;まだ改善すべき点は多くあって、HTMLに比べれば楽に書けるけど
   Markdownには劣ってる(それでも個人的にはMarkdownの記法がうるおぼえなのでmisakiの方が迷わずに書けますが)
   レベルなので、これからもっと自分が使いやすいよう修正していけたらと思っています。&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;まだまだ汚いブログのコードは以下。テンプレート内関数など多用してます。&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;&lt;a href=&quot;https://github.com/liquidz/liquidz.github.com/tree/master/_template&quot;&gt;https://github.com/liquidz/liquidz.github.com/tree/master/_template&lt;/a&gt;&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;ひとまずご報告まで&lt;/p&gt;</content></entry><entry><title>ClojureでJekyllライクなブログジェネレータ「misaki」を作ったった</title><link>http://liquidz.github.io/2012/04/misaki.html</link><updated>2012-04-01T00:00:00</updated><id>http://liquidz.github.io/2012/04/misaki.html</id><content type="html">&lt;p class=&quot;paragraph&quot;&gt;エイプリルフールに被ってしまいましたが、
   Clojureで&lt;a href=&quot;https://github.com/mojombo/jekyll&quot;&gt;Jekyll&lt;/a&gt;ライクなブログジェネレータを作りました。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/liquidz/misaki&quot;&gt;&lt;img alt=&quot;misaki logo&quot; src=&quot;/img/post/misaki-logo.png&quot; /&gt;&lt;/a&gt;&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;&lt;a href=&quot;https://github.com/liquidz/misaki&quot;&gt;misaki / Jekyll inspired static site generator&lt;/a&gt;&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;当ブログはJekyllを使ってGitHub Pages上で運用しているのですが、
   &lt;code class=&quot;prettyprint&quot;&gt;jekyll --server&lt;/code&gt; のファイル変更から反映までの遅さ(何か手があるのかもしれないですが)
   とClojurianで主にClojureのブログなのにrubyで運用してるのが納得いかなかったので(rubyは好きですが)
   作ってみました。&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;&quot;misaki&quot; という名前は Jekyll が人名なので同じく人の名前にしたかったのと
    &quot;美しく咲く&quot; というがちょっと綺麗かなぁという軽いのりで付けてます。&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;あ、でも伊東美咲は好きです。綺麗なお姉さん好きです。&lt;/p&gt;&lt;h2 id=&quot;G__1980&quot;&gt;&lt;span&gt;サ&lt;/span&gt;ンプルの実行&lt;a class=&quot;dagger&quot; href=&quot;#G__1980&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h2&gt;&lt;p class=&quot;paragraph&quot;&gt;以下のコマンドでGitHubからとってこれます。&lt;/p&gt;&lt;pre class=&quot;prettyprint&quot;&gt;$ git clone git://github.com/liquidz/misaki.git
$ cd misaki
$ lein run sample&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;ローカルサーバが起動するので &lt;a href=&quot;http://localhost:8080/&quot;&gt;http://localhost:8080/&lt;/a&gt; にアクセスしましょう。&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;なおサンプルと同じものをデモページとして&lt;a href=&quot;http://liquidz.github.com/project/misaki/&quot;&gt;こちら&lt;/a&gt;にも公開しています。&lt;/p&gt;&lt;h2 id=&quot;G__1981&quot;&gt;&lt;span&gt;自&lt;/span&gt;分のブログを作る&lt;a class=&quot;dagger&quot; href=&quot;#G__1981&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h2&gt;&lt;p class=&quot;paragraph&quot;&gt;1からファイルを用意しても良いのですが、面倒だと思うのでサンプルをコピーして
   ローカルサーバを起動させましょう。&lt;/p&gt;&lt;pre class=&quot;prettyprint&quot;&gt;$ cp -pir sample your_blog
$ lein run your_blog&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;ローカルサーバの起動中は &lt;a href=&quot;https://github.com/ibdknox/watchtower&quot;&gt;watchtower&lt;/a&gt; でテンプレートファイルを監視しているので変更すれば自動的にHTMLへのコンパイルが走ります。&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;デフォルトではコピーしたディレクトリ配下の &quot;_template&quot; 内にテンプレート(.clj)、ポストファイル(_post)、レイアウトファイル(_layout)が
   配置されているので、そのあたりを編集しつつブラウザで確認という流れで作っていくことになります。&lt;/p&gt;&lt;pre class=&quot;prettyprint&quot;&gt;$ vi your_blog/_template/index.html.clj&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;なおテンプレートなどディレクトリ構成の詳細はドキュメントの &lt;a href=&quot;https://github.com/liquidz/misaki/wiki/Directory-Structure&quot;&gt;Directory Structure&lt;/a&gt; を参照してください。&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;ただドキュメントよりサンプルソースを見たほうが早いかもしれないです。&lt;/p&gt;&lt;h2 id=&quot;G__1982&quot;&gt;&lt;span&gt;テ&lt;/span&gt;ンプレートサンプル&lt;a class=&quot;dagger&quot; href=&quot;#G__1982&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h2&gt;&lt;p class=&quot;paragraph&quot;&gt;テンプレートはclojureのコードになっています。HTMLへのコンパイルには &lt;a href=&quot;https://github.com/weavejester/hiccup&quot;&gt;hiccup&lt;/a&gt; を使っているのでhiccupを使ったことのある方であればすんなり入れるかなと思っています。&lt;/p&gt;&lt;pre class=&quot;prettyprint lang-clj&quot;&gt;;; テンプレートオプション
;; ----
;; レイアウト定義
; @layout  default
;; テンプレートタイトル
; @title   sample tempalte

;; Clojureコードなので関数定義できます
(defn h1 [s] [:h1 s])

;; site変数でテンプレートオプションにアクセスできます
(h1 (:title site))
[:p &amp;quot;Welcome to misaki world!&amp;quot;]

;; コードハイライト
#-CLJ
(println &amp;quot;google-code-prettify highlight!&amp;quot;)
CLJ&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;テンプレートではコメント内に以下のフォーマットでテンプレートオプションを定義できます。&lt;/p&gt;&lt;pre class=&quot;prettyprint lang-clj&quot;&gt;; @key value&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;テンプレートオプションではそのテンプレートに適用するレイアウトを指定したり、
    テンプレート自体のタイトルを定義することができます。&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;レイアウトはテンプレート同様にClojureコードなので
    オプションや関数を同様に定義することができます。
    共通して使う定義や関数についてはレイアウト側で定義しておくと便利かもしれないです。&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;レイアウトの詳細についてはドキュメントの &lt;a href=&quot;https://github.com/liquidz/misaki/wiki/Edit-Template&quot;&gt;Edit Template&lt;/a&gt; の &quot;Layout file&quot; の項目を参照してください。&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;なおテンプレートオプションへのアクセスについては
   上記サンプルにもある通り &lt;code class=&quot;prettyprint&quot;&gt;site&lt;/code&gt; といった特別な変数が利用できます。&lt;/p&gt;&lt;h3 id=&quot;G__1983&quot;&gt;&lt;span&gt;s&lt;/span&gt;ite の内容&lt;a class=&quot;dagger&quot; href=&quot;#G__1983&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h3&gt;&lt;pre class=&quot;prettyprint lang-clj&quot;&gt;site
;=&amp;gt; {:title &amp;quot;sample template&amp;quot;
;    :date  org.joda.time.DateTime  ;更新日
;    :posts [post1 post2 ... postN]&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;&lt;code class=&quot;prettyprint&quot;&gt;:posts&lt;/code&gt;の内容については後述します。&lt;/p&gt;&lt;h2 id=&quot;G__1984&quot;&gt;&lt;span&gt;エ&lt;/span&gt;ントリーの追加&lt;a class=&quot;dagger&quot; href=&quot;#G__1984&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h2&gt;&lt;p class=&quot;paragraph&quot;&gt;デフォルトでは _template/_posts/ 配下にファイルを作成することで
    ブログのエントリーを追加することができます。&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;エントリーファイルはJekyll同様にファイル名のフォーマットが以下のように決まっています。&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;&lt;strong&gt;YYYY-MM-DD-タイトル.html.clj&lt;/strong&gt;&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;このファイル名が &lt;strong&gt;/YYYY/MM/タイトル.html&lt;/strong&gt; というURLに対応します。&lt;/p&gt;&lt;h3 id=&quot;G__1985&quot;&gt;&lt;span&gt;(&lt;/span&gt;:posts site) の内容&lt;a class=&quot;dagger&quot; href=&quot;#G__1985&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h3&gt;&lt;pre class=&quot;prettyprint lang-clj&quot;&gt;(first (:posts site))
;=&amp;gt; {:title &amp;quot;post title&amp;quot;
;    :url   &amp;quot;post url&amp;quot;
;    :date  org.joda.time.DateTime  ;ファイル名の日付
;    :file  java.io.File ; エントリーファイル
;    :lazy-content エントリーの内容(clojure.lang.Delay) }&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;なおテンプレート編集やレイアウトに関する詳細はドキュメントの &lt;a href=&quot;https://github.com/liquidz/misaki/wiki/Edit-Template&quot;&gt;Edit Template&lt;/a&gt; を参照してください。&lt;/p&gt;&lt;h2 id=&quot;G__1986&quot;&gt;&lt;span&gt;出&lt;/span&gt;力されたHTML&lt;a class=&quot;dagger&quot; href=&quot;#G__1986&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h2&gt;&lt;p class=&quot;paragraph&quot;&gt;今回の例でいえば &quot;your_blog/&quot; ディレクトリ配下がドキュメントルートになり
    コンパイルされたHTMLはすべて your_blog 配下に出力されます。&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;なのでGitHub Pagesへ反映する場合にはこのディレクトリ毎pushしてしまえば良いのですが、
    その場合、テンプレートファイルも一緒にpushされます。&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;これは私自信がテンプレートとHTMLを別レポジトリで管理したくないから
    という理由でこのようなディレクトリ構成にしているのですが、
    もしテンプレートとHTMLを別々に管理したい場合には _config.clj でmisaki内で扱うディレクトリのパスを扱っており、
    それを変更することで実現可能です。&lt;/p&gt;&lt;h2 id=&quot;G__1987&quot;&gt;&lt;span&gt;ド&lt;/span&gt;キュメント&lt;a class=&quot;dagger&quot; href=&quot;#G__1987&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h2&gt;&lt;p class=&quot;paragraph&quot;&gt;本エントリではあくまで紹介という体で全部の機能は紹介していませんし、
   紹介している機能でも詳細を省いたりしています。&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;少しでも興味をもっていただけたのならば、GitHubの &lt;a href=&quot;https://github.com/liquidz/misaki/wiki&quot;&gt;Wiki&lt;/a&gt; にまとめていますのでご参照ください。&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;なお英文はかなり適当です。。&lt;/p&gt;&lt;h2 id=&quot;G__1988&quot;&gt;&lt;span&gt;最&lt;/span&gt;後に&lt;a class=&quot;dagger&quot; href=&quot;#G__1988&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h2&gt;&lt;p class=&quot;paragraph&quot;&gt;まだアルファバージョンということでとりあえず動くかな？というレベルです。
    今後の流れとしてはまずはこのブログ自体をJekyllからmisakiに移行させて
    足りない機能などあれば追加していきたいと思っています。&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;またClojureScriptにも対応させてJSを置き換えたいですし、
    CSSまわりで良いライブラリがあればそれを導入して、
    前回のエントリのタイトルじゃないですが、全部Clojureでブログ運用
    とか出来ても良いのかなぁと思っています。&lt;/p&gt;&lt;h3 id=&quot;G__1989&quot;&gt;&lt;span&gt;参&lt;/span&gt;考ページ&lt;a class=&quot;dagger&quot; href=&quot;#G__1989&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;https://github.com/mojombo/jekyll&quot;&gt;Jekyll&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;http://thegeez.github.com/2012/03/15/static_blog_on_github_with_enlive.html&quot;&gt;Simple static blog with Clojure&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;http://d.hatena.ne.jp/nokturnalmortum/20100527/1274961805&quot;&gt;Clojureのリードマクロでヒアドキュメント実装してみた&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;</content></entry><entry><title>全部Clojureのターン(noir+noir-cljs)</title><link>http://liquidz.github.io/2012/03/clojurescript.html</link><updated>2012-03-18T00:00:00</updated><id>http://liquidz.github.io/2012/03/clojurescript.html</id><content type="html">&lt;p class=&quot;paragraph&quot;&gt;node.jsがサーバ、クライアントをJSだけで書けるのに対して、Clojureも&lt;a href=&quot;https://github.com/clojure/clojurescript&quot;&gt;ClojureScript&lt;/a&gt;を使えばサーバ、クライアントを1つの言語で書けます。&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;さらにClojureには&lt;a href=&quot;https://github.com/weavejester/hiccup&quot;&gt;hiccup&lt;/a&gt;というS式を使ったテンプレートエンジンがあるので&lt;strong&gt;サーバ(ビューも含め)+クライアントを全部Clojureで書けます。&lt;/strong&gt;&lt;/p&gt;&lt;p class=&quot;paragraph&quot; style=&quot;font-size: 50px;&quot;&gt;まさに全部Clojureのターン！&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;今回は &lt;a href=&quot;http://webnoir.org/&quot;&gt;noir&lt;/a&gt; と &lt;a href=&quot;https://github.com/ibdknox/noir-cljs&quot;&gt;noir-cljs&lt;/a&gt; を使って、単純にボタンを押してテキストを変更するだけのアプリ(?)を作るまでの手順です。&lt;/p&gt;&lt;h2 id=&quot;G__2016&quot;&gt;&lt;span&gt;n&lt;/span&gt;oirのインストール&lt;a class=&quot;dagger&quot; href=&quot;#G__2016&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h2&gt;&lt;p class=&quot;paragraph&quot;&gt;まずはnoirをインストールしましょう。&lt;/p&gt;&lt;pre class=&quot;prettyprint&quot;&gt;lein plugin install lein-noir 1.2.1&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;次にサンプルアプリを作成します。&lt;/p&gt;&lt;pre class=&quot;prettyprint&quot;&gt;lein noir new zenbu-clojure
cd zenbu-clojure&lt;/pre&gt;&lt;h2 id=&quot;G__2017&quot;&gt;&lt;span&gt;n&lt;/span&gt;oir-cljsの設定&lt;a class=&quot;dagger&quot; href=&quot;#G__2017&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h2&gt;&lt;p class=&quot;paragraph&quot;&gt;noir-cljsのREADMEに沿って project.clj を修正します。&lt;/p&gt;&lt;h3 id=&quot;G__2018&quot;&gt;&lt;span&gt;p&lt;/span&gt;roject.clj&lt;a class=&quot;dagger&quot; href=&quot;#G__2018&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h3&gt;&lt;pre class=&quot;prettyprint lang-clj&quot;&gt;(defproject zenbu-clojure &amp;quot;0.1.0-SNAPSHOT&amp;quot;
            :description &amp;quot;FIXME: write this!&amp;quot;
            :dependencies [[org.clojure/clojure &amp;quot;1.3.0&amp;quot;]
                           [noir &amp;quot;1.2.1&amp;quot;]
                           [noir-cljs &amp;quot;0.2.5&amp;quot;]] ; 追加
            :main ^{:skip-aot true} zenbu-clojure.server) ; aotコンパイルをスキップ&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;次に src ディレクトリ配下の .cljs ファイルが変更された時に自動的にコンパイルが走るよう
   server.clj を変更します。&lt;/p&gt;&lt;h3 id=&quot;G__2019&quot;&gt;&lt;span&gt;s&lt;/span&gt;rc/zenbu_clojure/server.clj&lt;a class=&quot;dagger&quot; href=&quot;#G__2019&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h3&gt;&lt;pre class=&quot;prettyprint lang-clj&quot;&gt;(ns zenbu-clojure.server
  (:require [noir.server :as server]))

(server/load-views &amp;quot;src/zenbu_clojure/views/&amp;quot;)

(defn -main [&amp;amp; m]
  (let [mode (keyword (or (first m) :dev))
        port (Integer. (get (System/getenv) &amp;quot;PORT&amp;quot; &amp;quot;8080&amp;quot;))]
    (noir.cljs.core/start mode) ; ここを追加
    (server/start port {:mode mode
                        :ns 'zenbu-clojure})))&lt;/pre&gt;&lt;h2 id=&quot;G__2020&quot;&gt;&lt;span&gt;テ&lt;/span&gt;ンプレート修正&lt;a class=&quot;dagger&quot; href=&quot;#G__2020&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h2&gt;&lt;p class=&quot;paragraph&quot;&gt;まずはコンパイルされた cljs を読み込むようレイアウトを修正します&lt;/p&gt;&lt;h3 id=&quot;G__2021&quot;&gt;&lt;span&gt;s&lt;/span&gt;rc/zenbu_clojure/views/common.clj&lt;a class=&quot;dagger&quot; href=&quot;#G__2021&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h3&gt;&lt;pre class=&quot;prettyprint lang-clj&quot;&gt;(ns zenbu-clojure.views.common
  (:use [noir.core :only [defpartial]]
        [hiccup.page-helpers :only [include-css html5]])
  (:require [noir.cljs.core :as noir-cljs])) ; 追加

(defpartial layout [&amp;amp; content]
            (html5
              [:head
               [:title &amp;quot;zenbu-clojure&amp;quot;]
               (include-css &amp;quot;/css/reset.css&amp;quot;)]
              [:body
               [:div#wrapper
                content]
               (noir-cljs/include-scripts) ; コンパイルしたcljsを読み込み
               ]))&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;次に welcome ページにちょっと手を入れます&lt;/p&gt;&lt;h3 id=&quot;G__2022&quot;&gt;&lt;span&gt;s&lt;/span&gt;rc/zenbu_clojure/views/welcome.clj&lt;a class=&quot;dagger&quot; href=&quot;#G__2022&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h3&gt;&lt;pre class=&quot;prettyprint lang-clj&quot;&gt;(ns zenbu-clojure.views.welcome
  (:require [zenbu-clojure.views.common :as common]
            [noir.content.getting-started])
  (:use [noir.core :only [defpage]]
        [hiccup.core :only [html]]))

(defpage &amp;quot;/&amp;quot; [] ; index ページに変更
         (common/layout
           [:button {:id &amp;quot;btn&amp;quot;} &amp;quot;全部...&amp;quot;] ; ボタンを追加
           [:p {:id &amp;quot;text&amp;quot;} &amp;quot;Welcome to zenbu-clojure&amp;quot;] ; id属性を追加
           ))&lt;/pre&gt;&lt;h2 id=&quot;G__2023&quot;&gt;&lt;span&gt;C&lt;/span&gt;lojureScript作成&lt;a class=&quot;dagger&quot; href=&quot;#G__2023&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h2&gt;&lt;p class=&quot;paragraph&quot;&gt;最後にClojureScriptを書きます。&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;なお個人的にちょっとハマった点として
    noir-cljs 0.2.5 では &quot;cljs&quot; という名前のディレクトリは
    ClojureScriptとして認識されてしまうようでサーバ起動時にエラーになってしまいます。&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;(同作者の&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;&lt;a href=&quot;https://github.com/ibdknox/watchtower&quot;&gt;watchtower&lt;/a&gt;&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;というライブラリによる挙動で、pull requestだけ出してあるのでもしマージされれば問題なくなるかもしれません)&lt;/p&gt;&lt;p class=&quot;paragraph add&quot;&gt;2012-04-08 追記: マージしていただいたので ver 0.1.1 を使えば問題ありません&lt;/p&gt;&lt;h3 id=&quot;G__2024&quot;&gt;&lt;span&gt;s&lt;/span&gt;rc/zenbu_clojure/mycljs/core.cljs&lt;a class=&quot;dagger&quot; href=&quot;#G__2024&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h3&gt;&lt;pre class=&quot;prettyprint lang-clj&quot;&gt;(ns zenbu-clojure.mycljs.core
  (:reuiqre [clojure.browser.event :as event]
            [clojure.browser.dom :ad dom]))

(defn click-event
  &amp;quot;#btnクリック時のクリックイベント&amp;quot;
  []
  (dom/set-text (dom/get-element &amp;quot;text&amp;quot;) &amp;quot;Clojureのターン!&amp;quot;))

(defn init
  &amp;quot;onload時に呼ばれる関数&amp;quot;
  []
  (event/listen (dom/get-element &amp;quot;btn&amp;quot;) :click click-event))

; onloadイベントを追加
(goog.events/listen js/window goog.events.EventType/LOAD init)&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;ここまできたらサーバを起動してみましょう。&lt;/p&gt;&lt;pre class=&quot;prettyprint&quot;&gt;lein run&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;ポート指定していなければ http://localhost:8080 で確認できます。&lt;/p&gt;&lt;h2 id=&quot;G__2025&quot;&gt;&lt;span&gt;最&lt;/span&gt;後に&lt;a class=&quot;dagger&quot; href=&quot;#G__2025&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h2&gt;&lt;p class=&quot;paragraph&quot;&gt;今回はアプリというのにはおこがましいくらい単純なものでしたが、
    全部Clojureで書けることはお見せできたと思います。&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;私自身、まだClojureScriptにあまり慣れていないので要勉強ですが、
    もう少しまともなアプリが書けるようになったらまたまとめてみようかと思います。&lt;/p&gt;&lt;p class=&quot;paragraph&quot; style=&quot;color: #777;&quot;&gt;なおここまで書いて &lt;a href=&quot;https://github.com/ibdknox/cljs-template&quot;&gt;cljs-template&lt;/a&gt; に気づきました、、、こっちを使えばもっと簡単にできそうなのであとで試してみたいと思います。&lt;/p&gt;&lt;p class=&quot;paragraph add&quot;&gt;追記&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;参考ページを書き忘れていました。。ClojureScriptの記述については以下を参考にさせていただきました。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;http://dev.classmethod.jp/ria/clojurescript/&quot;&gt;Clojure Scriptを使ってみる&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;http://qiita.com/items/1548&quot;&gt;DOM Element を def で束縛する&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;</content></entry><entry><title>Play frameworkでHttpServletRequestを扱うメモ</title><link>http://liquidz.github.io/2012/02/play-httpservletrequest.html</link><updated>2012-02-28T00:00:00</updated><id>http://liquidz.github.io/2012/02/play-httpservletrequest.html</id><content type="html">&lt;p class=&quot;paragraph add&quot;&gt;本記事の内容は Play framework 開発者の方々意向で
 ドキュメントに載せていない隠しAPI的な位置づけの機能を使っています。

 どうしても使わざるを得ない場合を除いては使わない方が良いかと思います。&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;ちょっとしたものを Play framework(Java) で書いて
   Tomcat上で動かすということをしているのですが、&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;Apache -&gt;(mod_proxy_ajp)-&gt; Tomcat&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p class=&quot;paragraph&quot;&gt;という連携でApacheからTomcatに渡される環境変数を
    playで受け取れなくて困っていました。&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;そこで色々調べたのですが HttpServletRequest を扱う方法がありました。&lt;/p&gt;&lt;p class=&quot;paragraph&quot; style=&quot;font-size: x-large;&quot;&gt;隠されてましたが&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/playframework/play/pull/99&quot;&gt;#99: Lighthouse 588 patch by grandfatha for playframework/play - Pull Request - GitHub&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p class=&quot;paragraph&quot;&gt;すべてはここに書いてあります。
   ものすごく意訳すると&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;こんなに美しくないアイデアはないけど、&lt;/p&gt;&lt;p&gt;Servlet APIにアクセスせざるを得ないユーザがいるのは事実。&lt;/p&gt;&lt;p&gt;モジュールに切り離せればベストだけどそれもできないからマージするよ。&lt;/p&gt;&lt;p&gt;でもこんなのドキュメントになんか書いてあげないんだからねっ！&lt;/p&gt;&lt;/blockquote&gt;&lt;p class=&quot;paragraph&quot;&gt;ということでコントローラ内から以下のコードでアクセスできます。&lt;/p&gt;&lt;pre class=&quot;prettyprint&quot;&gt;HttpServletRequest req = (HttpServletRequest)request.args.get(ServletWrapper.SERVLET_REQ);&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;上記の通り、あえてドキュメントに書かれていないことなので
   2度目になりますが、どうしてもという場合以外は使わない方が良いと思います。&lt;/p&gt;</content></entry><entry><title>VimFiler上で「送る」機能を実装するプラグイン作ったった</title><link>http://liquidz.github.io/2012/02/vimfiler.html</link><updated>2012-02-12T00:00:00</updated><id>http://liquidz.github.io/2012/02/vimfiler.html</id><content type="html">&lt;p class=&quot;paragraph add&quot;&gt;2012-02-12 @ShougoMatsu さんにTwitterで指摘していただいたところを修正・追記しています。&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;メインのファイラをVimFilerに移行中です。&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;Ubuntuではシェルのみで操作していたのですが、
   会社のWindows環境ではずっと&lt;a href=&quot;http://homepage1.nifty.com/bee/df/&quot;&gt;DF&lt;/a&gt;を愛用していて、
   それと同じような環境をUbuntuでも使いたいと思っていました。&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;そこでVimmerとしてはVimFilerだろ！ということでいろいろと設定している中で
   VimFilerにエクスプローラの「送る」ライクな機能を提供するプラグインを作ってしまったので紹介です。&lt;/p&gt;&lt;h2 id=&quot;G__2078&quot;&gt;&lt;span&gt;s&lt;/span&gt;endto plugin for vimfiler&lt;a class=&quot;dagger&quot; href=&quot;#G__2078&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h2&gt;&lt;dl&gt;&lt;dt&gt;github&lt;/dt&gt;&lt;dd&gt;&lt;a href=&quot;https://github.com/liquidz/vimfiler-sendto&quot;&gt;https://github.com/liquidz/vimfiler-sendto&lt;/a&gt;&lt;/dd&gt;&lt;/dl&gt;&lt;p class=&quot;paragraph&quot;&gt;もともとVimFiler上で &quot;!&quot; コマンドを使えば外部コマンドでファイルを実行できるのですが、
    毎回入力するのが面倒だったのと unite.vim のインターフェイスを使って選択できれば
    より便利なんじゃないかということで書いてみた次第です。
    なおVimScriptはほどんど初心者に近いので書き方でおかしなところがあればご指摘ください。。&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;設定方法などはGitHub上のREADMEを参照してください。&lt;/p&gt;&lt;h2 id=&quot;G__2079&quot;&gt;&lt;span&gt;.&lt;/span&gt;vimrc for vimfiler&lt;a class=&quot;dagger&quot; href=&quot;#G__2079&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h2&gt;&lt;p class=&quot;paragraph&quot;&gt;以下、おまけですが .vimrc に書いているVimFiler向けの設定です。&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;基本的にはDFのキーマップに合わせて変更しているのと&lt;s&gt;Ubuntuではシステム側の関連付けがVimFiler上では使えなかったので
       xdg-open を明示的に関連付けています。
       (mpg, wmv, rm あたりが開けないのは困りますよね！&lt;/s&gt;&lt;/p&gt;&lt;p class=&quot;paragraph add&quot;&gt;Ubuntuでの関連付けが使えない件はEnter(VimFilerの関連付け)で開けなかっただけで
 x(システムの関連付け)であれば開けました。勘違いスミマセン&lt;/p&gt;&lt;pre class=&quot;prettyprint&quot;&gt;let g:vimfiler_safe_mode_by_default = 0
let g:vimfiler_as_default_explorer = 1
let g:vimfiler_sort_type = &amp;quot;Time&amp;quot;
let g:vimfiler_sendto = {
\   'unzip' : 'unzip'
\ , 'Inkscape ベクターグラフィックエディタ' : 'inkspace'
\ , 'GIMP 画像エディタ' : 'gimp'
\ , 'gedit' : 'gedit'
\ }

nnoremap &amp;lt;Leader&amp;gt;&amp;lt;leader&amp;gt; :VimFiler&amp;lt;CR&amp;gt;
aug VimFilerKeyMapping
    au!
    autocmd FileType vimfiler call s:vimfiler_local()

    function! s:vimfiler_local()
        &amp;quot; キーマップのカスタマイズ
        nmap &amp;lt;buffer&amp;gt; &amp;lt;C-r&amp;gt; &amp;lt;Plug&amp;gt;(vimfiler_rename_file)
        nmap &amp;lt;buffer&amp;gt; a &amp;lt;Plug&amp;gt;(vimfiler_toggle_mark_all_lines)
        nmap &amp;lt;buffer&amp;gt; m &amp;lt;Plug&amp;gt;(vimfiler_set_current_mask)
        nmap &amp;lt;buffer&amp;gt; M &amp;lt;Plug&amp;gt;(vimfiler_move_file)
        nmap &amp;lt;buffer&amp;gt; D &amp;lt;Plug&amp;gt;(vimfiler_make_directory)
        nmap &amp;lt;buffer&amp;gt; h &amp;lt;Plug&amp;gt;(vimfiler_smart_h)zz
        nmap &amp;lt;buffer&amp;gt; F &amp;lt;Plug&amp;gt;(vimfiler_new_file)
        &amp;quot; sendto呼び出し
        nnoremap &amp;lt;buffer&amp;gt; &amp;lt;Leader&amp;gt;s :Unite sendto&amp;lt;CR&amp;gt;

        &amp;quot; 関連付け
        if has('unix')
            call vimfiler#set_execute_file('sh', 'sh')
            &amp;quot; 2/12 不要になったのでコメントアウト
            &amp;quot;for ext in [&amp;quot;html&amp;quot;, &amp;quot;htm&amp;quot;, &amp;quot;pdf&amp;quot;, &amp;quot;jpg&amp;quot;, &amp;quot;gif&amp;quot;, &amp;quot;png&amp;quot;, &amp;quot;svg&amp;quot;, &amp;quot;zip&amp;quot;, &amp;quot;lzh&amp;quot;, &amp;quot;mp3&amp;quot;, &amp;quot;mpg&amp;quot;, &amp;quot;wmv&amp;quot;, &amp;quot;rm&amp;quot;, &amp;quot;flv&amp;quot;]
            &amp;quot;    call vimfiler#set_execute_file(ext, 'xdg-open')
            &amp;quot;endfor
        endif

        &amp;quot; Unite bookmark連携
        nnoremap &amp;lt;buffer&amp;gt; z &amp;lt;C-u&amp;gt;:Unite bookmark&amp;lt;CR&amp;gt;
        nnoremap &amp;lt;buffer&amp;gt; A &amp;lt;C-u&amp;gt;:UniteBookmarkAdd&amp;lt;CR&amp;gt;
        &amp;quot; Unite bookmarkのアクションをVimFilerに
        call unite#custom_default_action('source/bookmark/directory' , 'vimfiler')
        &amp;quot; incremental search
        nnoremap &amp;lt;buffer&amp;gt; / /^\s*\(\|-\\|\|+\\|+\\|-\) \zs
    endfunction
aug END&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;以上です。&lt;/p&gt;&lt;p class=&quot;paragraph add&quot;&gt;追記&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;ちなみに vimfiler#set_execute_file は拡張子の指定にコンマ区切りが使えるそうです。
    (現状、コンマの前後にスペースは入れられないようです)&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;なので上記のように for で回す必要はありませんでした。&lt;/p&gt;&lt;pre class=&quot;prettyprint&quot;&gt;call vimfiler#set_execute_file(&amp;quot;jpg,png&amp;quot;, 'xdg-open')&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;また sendto に似た機能で g:vimfiler_execute_file_list というのがすでにありました。&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;以下のように指定するとjpgファイルを開こうとした場合に
    Uniteのインターフェイスで xdg-open, gimp のどちらで開くかを指定できます。&lt;/p&gt;&lt;pre class=&quot;prettyprint&quot;&gt;let g:vimfiler_execute_file_list = {
\   'jpg' : ['xdg-open', 'gimp']
\ }&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;sendtoでは必要な時だけ指定するようにできることと、
   ワイルドカードの追加などで差別化していければと思います。&lt;/p&gt;</content></entry><entry><title>実践(?)Compojure</title><link>http://liquidz.github.io/2011/12/practical-compojure.html</link><updated>2011-12-03T00:00:00</updated><id>http://liquidz.github.io/2011/12/practical-compojure.html</id><content type="html">&lt;p class=&quot;paragraph&quot;&gt;この記事は&lt;a href=&quot;http://partake.in/events/393770ce-4637-4f07-bc14-a1f5120eab71&quot;&gt;Clojrure Advent Calendar 2011&lt;/a&gt;の参加記事です。&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;今回はCompojureでウェブアプリを作る際に使える
   ある程度実践的(?)なTipsなどを紹介します。&lt;/p&gt;&lt;strong&gt;長文なのでご注意ください&lt;/strong&gt;&lt;h2 id=&quot;G__2106&quot;&gt;&lt;span&gt;C&lt;/span&gt;ompojureとは&lt;a class=&quot;dagger&quot; href=&quot;#G__2106&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h2&gt;&lt;p class=&quot;paragraph&quot;&gt;&lt;a href=&quot;https://github.com/weavejester/compojure&quot;&gt;Compojure&lt;/a&gt;はClojure向けの軽量ウェブフレームワークです。&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;Clojure版Sinatraのようなフレームワークでウェブアプリをシンプルに記述できることが特徴で、&lt;a href=&quot;https://github.com/mmcgrana/ring&quot;&gt;ring&lt;/a&gt;というウェブアプリケーションライブラリがベースになっています。&lt;/p&gt;&lt;h2 id=&quot;G__2107&quot;&gt;&lt;span&gt;H&lt;/span&gt;ello World&lt;a class=&quot;dagger&quot; href=&quot;#G__2107&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h2&gt;&lt;p class=&quot;paragraph&quot;&gt;最初にベースとなるHelloWorldを作ります。
   HelloWorldの作り方自体はググれば他にたくさん記事が見つかると思うので
   詳細な説明は割愛して、コード内のコメントで軽く補足します。&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;なおこれから先は&lt;a href=&quot;https://github.com/technomancy/leiningen&quot;&gt;Leiningen&lt;/a&gt;がインストール済みであることを前提にしています。&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;プロジェクトの作成&lt;/p&gt;&lt;pre class=&quot;prettyprint&quot;&gt;$ lein new helloworld
$ cd helloworld&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;project.clj の編集&lt;/p&gt;&lt;pre class=&quot;prettyprint lang-clj&quot;&gt;(defproject helloworld &amp;quot;1.0.0-SNAPSHOT&amp;quot;
  :description &amp;quot;FIXME: write description&amp;quot;
  :dependencies [[org.clojure/clojure &amp;quot;1.3.0&amp;quot;]
                 [compojure &amp;quot;0.6.5&amp;quot;] ; 12/03時点で最新のタグ
                 [ring/ring-jetty-adapter &amp;quot;0.3.11&amp;quot;]]
  :main helloworld.core)&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;src/helloworld/core.clj の編集&lt;/p&gt;&lt;pre class=&quot;prettyprint lang-clj&quot;&gt;(ns helloworld.core
  (:use
    [compojure.core :only [defroutes GET]]
    [compojure.route :only [not-found]]
    [ring.adapter.jetty :only [run-jetty]]))

(defroutes app
  (GET &amp;quot;/&amp;quot; req &amp;quot;hello world&amp;quot;)
  ; defroutesは定義した順に処理するためnot-foundは最後に書く
  (not-found &amp;quot;NOT FOUND&amp;quot;))

(defn -main []
  ; heroku向けのport取得
  (let [port (Integer/parseInt (get (System/getenv) &amp;quot;PORT&amp;quot; &amp;quot;8080&amp;quot;))]
    (run-jetty app {:port port})))&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;実行&lt;/p&gt;&lt;pre class=&quot;prettyprint&quot;&gt;$ lein deps
$ lein run
$ open http://localhost:8080&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;Hello World!!&lt;/p&gt;&lt;h2 id=&quot;G__2108&quot;&gt;&lt;span&gt;静&lt;/span&gt;的ファイルを扱う&lt;a class=&quot;dagger&quot; href=&quot;#G__2108&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h2&gt;&lt;p class=&quot;paragraph&quot;&gt;無事HelloWorldが表示できました。&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;あとはhiccupやenliveといったテンプレートエンジンを使えば動的な画面は問題ないでしょう。
    では静的な画面は？というと以下のようにします。&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;project.clj に以下を追加&lt;/p&gt;&lt;pre class=&quot;prettyprint lang-clj&quot;&gt;:web-content &amp;quot;public&amp;quot;&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;src/helloworld/core.clj のルートを編集&lt;/p&gt;&lt;pre class=&quot;prettyprint lang-clj&quot;&gt;(ns helloworld.core
  (:use
    [compojure.core :only [defroutes GET]]
    ; filesを追加
    [compojure.route :only [not-found files]]
    [ring.adapter.jetty :only [run-jetty]]))

(defroutes app
  (GET &amp;quot;/&amp;quot; req &amp;quot;hello world&amp;quot;)
  (files &amp;quot;/&amp;quot;) ; publicディレクトリを&amp;quot;/&amp;quot;にひもづける
  (not-found &amp;quot;NOT FOUND&amp;quot;))&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;静的ファイルを用意&lt;/p&gt;&lt;pre class=&quot;prettyprint&quot;&gt;$ pwd
プロジェクトディレクトリ
$ mkdir public; cd public
$ echo NEKO &amp;gt; neko.txt&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;Jettyの再起動を再起動して http://localhost:8080/neko.txt へアクセスすれば
   静的ファイルを参照できます。&lt;/p&gt;&lt;h2 id=&quot;G__2109&quot;&gt;&lt;span&gt;開&lt;/span&gt;発を効率化&lt;a class=&quot;dagger&quot; href=&quot;#G__2109&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h2&gt;&lt;p class=&quot;paragraph&quot;&gt;先ほどの静的ファイルへの対応では修正後にJettyを再起動しました。
   でも修正の度に再起動するのは効率的ではありません。&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;そこでring-develの&lt;code class=&quot;prettyprint&quot;&gt;reload&lt;/code&gt; と &lt;code class=&quot;prettyprint&quot;&gt;stacktrace&lt;/code&gt; を使いましょう。&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;project.clj に追加&lt;/p&gt;&lt;pre class=&quot;prettyprint lang-clj&quot;&gt;:dev-dependencies [[ring/ring-devel &amp;quot;0.3.11&amp;quot;]]&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;src/helloworld/core.clj の修正&lt;/p&gt;&lt;pre class=&quot;prettyprint lang-clj&quot;&gt;(ns helloworld.core
  (:use
    [compojure.core :only [defroutes GET]]
    [compojure.route :only [not-found files]]
    [ring.middleware reload stacktrace]
    [ring.adapter.jetty :only [run-jetty]]))

(defn index
  &amp;quot;/ にアクセスされたときの処理&amp;quot;
  [req]
  &amp;quot;hello world&amp;quot;)

(defroutes main-route
  (GET &amp;quot;/&amp;quot; req (index req)) ; 処理を関数に
  (GET &amp;quot;/err&amp;quot; _ (throw (Exception.))) ; stacktraceの確認用
  (files &amp;quot;/&amp;quot;)
  (not-found &amp;quot;NOT FOUND&amp;quot;))

(defroutes app
  (-&amp;gt; main-route
    (wrap-reload '[helloworld.core])
    wrap-stacktrace))&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;実行&lt;/p&gt;&lt;pre class=&quot;prettyprint&quot;&gt;$ lein deps
$ lein run&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;Jettyの再起動に関係なく index の戻り値が反映されるのが確認できたでしょうか？
   また &lt;code class=&quot;prettyprint&quot;&gt;stacktrace&lt;/code&gt; を使うと /err にアクセスした際に、画面上に例外の内容を表示させることができます。&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;なお &lt;code class=&quot;prettyprint&quot;&gt;reload&lt;/code&gt; ですが、&lt;code class=&quot;prettyprint&quot;&gt;defroutes&lt;/code&gt; 内の変更は反映されないようなので、
routeの変更の際にはJettyの再起動が必要です。(この点、対処方法があれば誰か教えてください。)&lt;/p&gt;&lt;h2 id=&quot;G__2110&quot;&gt;&lt;span&gt;M&lt;/span&gt;iddlewareで拡張&lt;a class=&quot;dagger&quot; href=&quot;#G__2110&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h2&gt;&lt;p class=&quot;paragraph&quot;&gt;先ほどの reload, stacktrace はringのmiddlewareと言われるもので、
    これらを使うとCompojureの挙動を拡張することができます。&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;主要なmiddlewareは以下の通りです。&lt;/p&gt;&lt;h3 id=&quot;G__2111&quot;&gt;&lt;span&gt;r&lt;/span&gt;ing.middleware.params/wrap-params&lt;a class=&quot;dagger&quot; href=&quot;#G__2111&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h3&gt;&lt;p class=&quot;paragraph&quot;&gt;QueryString, POSTデータを &lt;code class=&quot;prettyprint&quot;&gt;{:params request}&lt;/code&gt; に展開&lt;/p&gt;&lt;pre class=&quot;prettyprint lang-clj&quot;&gt;(defroutes main-routes
  (GET &amp;quot;/&amp;quot; {params :params}
    (get params &amp;quot;get_parameter&amp;quot;)))

(defroutes app
  (-&amp;gt; main-routes wrap-params))&lt;/pre&gt;&lt;h3 id=&quot;G__2112&quot;&gt;&lt;span&gt;r&lt;/span&gt;ing.middleware.nested-params/wrap-nested-params&lt;a class=&quot;dagger&quot; href=&quot;#G__2112&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h3&gt;&lt;p class=&quot;paragraph&quot;&gt;添字付きのパラメータをネストしたマップに展開。要 &lt;code class=&quot;prettyprint&quot;&gt;wrap-params&lt;/code&gt;。&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;なお展開できる階層は1階層のネストまで&lt;/p&gt;&lt;pre class=&quot;prettyprint lang-clj&quot;&gt;(defroutes main-routes
  (GET &amp;quot;/&amp;quot; {params :params} (str params)))

(defroutes app
  (-&amp;gt; main-routes wrap-nested-params wrap-params))&lt;/pre&gt;&lt;pre class=&quot;prettyprint&quot;&gt;$ open &amp;quot;http://localhost:8080/?a[b]=c&amp;amp;a[d]=e&amp;quot;&lt;/pre&gt;&lt;pre class=&quot;prettyprint lang-clj&quot;&gt;{&amp;quot;a&amp;quot; {&amp;quot;d&amp;quot; &amp;quot;e&amp;quot;, &amp;quot;b&amp;quot; &amp;quot;c&amp;quot;}}&lt;/pre&gt;&lt;h3 id=&quot;G__2113&quot;&gt;&lt;span&gt;r&lt;/span&gt;ing.middleware.keyword-params/wrap-keyword-params&lt;a class=&quot;dagger&quot; href=&quot;#G__2113&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h3&gt;&lt;p class=&quot;paragraph&quot;&gt;パラメータ名をStringからKeywordに変換。&lt;code class=&quot;prettyprint&quot;&gt;wrap-params&lt;/code&gt;, &lt;code class=&quot;prettyprint&quot;&gt;wrap-nested-params&lt;/code&gt;と一緒に使う&lt;/p&gt;&lt;pre class=&quot;prettyprint lang-clj&quot;&gt;(defroutes main-routes
  ; 分配束縛が楽
  (GET &amp;quot;/&amp;quot; { {:keys [param1 param2]} :params}
    (str &amp;quot;param1 = &amp;quot; param1 &amp;quot;, param2 = &amp;quot; param2)))

(defroutes app
  (-&amp;gt; main-routes wrap-keyword-params wrap-params))&lt;/pre&gt;&lt;h3 id=&quot;G__2114&quot;&gt;&lt;span&gt;r&lt;/span&gt;ing.middleware.session&lt;a class=&quot;dagger&quot; href=&quot;#G__2114&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h3&gt;&lt;p class=&quot;paragraph&quot;&gt;セッションを扱う。
   セッション情報はリクエストの :session キーで渡される&lt;/p&gt;&lt;pre class=&quot;prettyprint lang-clj&quot;&gt;(ns helloworld.core
  (:use
    ..省略..
    [ring.util.response :only [redirect]]))

(defroutes main-routes
  (GET &amp;quot;/set/:vlue&amp;quot; [value]
    ; セッションのセットはレスポンスに :session を指定するだけ
    (assoc (redirect &amp;quot;/&amp;quot;) :session {:value value}))

  (GET &amp;quot;/&amp;quot; { {:keys [value], :or {value &amp;quot;no data&amp;quot;}} :session}
    (str &amp;quot;value = &amp;quot; value)))

(defroutes app
  (-&amp;gt; main-routes wrap-session))&lt;/pre&gt;&lt;pre class=&quot;prettyprint&quot;&gt;$ open &amp;quot;http://localhost:8080/set/helloworld&amp;quot;&lt;/pre&gt;&lt;h3 id=&quot;G__2115&quot;&gt;&lt;span&gt;r&lt;/span&gt;ing.middleware.flash&lt;a class=&quot;dagger&quot; href=&quot;#G__2115&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h3&gt;&lt;p class=&quot;paragraph&quot;&gt;セッションを使って一時的なメッセージを保存。要 &lt;code class=&quot;prettyprint&quot;&gt;wrap-session&lt;/code&gt;。&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;リダイレクト先でちょろっとメッセージを表示したいときとかに使う&lt;/p&gt;&lt;pre class=&quot;prettyprint lang-clj&quot;&gt;(ns helloworld.core
  (:use
    ..省略..
    [ring.util.response :only [redirect]]))

(defroutes main-routes
  (GET &amp;quot;/set/:value&amp;quot; [value]
    ; flashのセットはレスポンスに :flash で指定
    (assoc (redirect &amp;quot;/&amp;quot;) :flash value))
  (GET &amp;quot;/&amp;quot; {flash :flash}
    (str &amp;quot;flash = &amp;quot; flash)))

(defroutes app
  (-&amp;gt; main-routes wrap-flash wrap-session))&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;flashをセット&lt;/p&gt;&lt;pre class=&quot;prettyprint&quot;&gt;$ open &amp;quot;http://localhost:8080/set/helloworld&amp;quot;&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;セットされてるのが確認できますが、もう一度アクセスすると一時的な情報なので削除されています。&lt;/p&gt;&lt;pre class=&quot;prettyprint&quot;&gt;$ open &amp;quot;http://localhost:8080/&amp;quot;&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;なお以下のような凡ミスはしないようご注意を&lt;/p&gt;&lt;a href=&quot;http://twitter.com/#!/uochan/status/141546228574982144&quot;&gt;http://twitter.com/#!/uochan/status/141546228574982144&lt;/a&gt;&lt;h3 id=&quot;G__2116&quot;&gt;&lt;span&gt;r&lt;/span&gt;ing.middleware.cookies&lt;a class=&quot;dagger&quot; href=&quot;#G__2116&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h3&gt;&lt;p class=&quot;paragraph&quot;&gt;クッキーを扱う。クッキー情報はリクエストの :cookies キーで渡される&lt;/p&gt;&lt;pre class=&quot;prettyprint lang-clj&quot;&gt;(ns helloworld.core
  (:use
    ..省略..
    [ring.util.response :only [redirect]]))

(defroutes main-routes
  (GET &amp;quot;/set/:value&amp;quot; [value]
    ; クッキーの設定はレスポンスの :cookies キーで行う
    (assoc (redirect &amp;quot;/&amp;quot;) :cookies {:hello {:value value :path &amp;quot;/&amp;quot;}}))
  (GET &amp;quot;/&amp;quot; {cookies :cookies}
    (str cookies)))

(defroutes app
  (-&amp;gt; main-routes wrap-cookies))&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;クッキー設定時には上記以外に
   :domain, :port, :max-age, :expires, :secure, :http-only
   が使えます。&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;詳細は以下のソース末尾を見ると良いです。&lt;/p&gt;&lt;a href=&quot;https://github.com/mmcgrana/ring/blob/master/ring-core/src/ring/middleware/cookies.clj&quot;&gt;https://github.com/mmcgrana/ring/blob/master/ring-core/src/ring/middleware/cookies.clj&lt;/a&gt;&lt;h3 id=&quot;G__2117&quot;&gt;&lt;span&gt;r&lt;/span&gt;ing.middleware.file/file&lt;a class=&quot;dagger&quot; href=&quot;#G__2117&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h3&gt;&lt;p class=&quot;paragraph&quot;&gt;静的ファイルを扱います。こちらだと project.clj に &lt;code class=&quot;prettyprint&quot;&gt;:web-content&lt;/code&gt; を指定しなくてもディレクトリを割り当てられます。&lt;/p&gt;&lt;pre class=&quot;prettyprint lang-clj&quot;&gt;(defroutes app
  (-&amp;gt; main-routes (wrap-file &amp;quot;public&amp;quot;)))&lt;/pre&gt;&lt;h3 id=&quot;G__2118&quot;&gt;&lt;span&gt;M&lt;/span&gt;iddlewareのちょっとした注意&lt;a class=&quot;dagger&quot; href=&quot;#G__2118&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h3&gt;&lt;p class=&quot;paragraph&quot;&gt;wrap系は処理をラップした関数を返すので
   &lt;code class=&quot;prettyprint&quot;&gt;-&gt;&lt;/code&gt;, &lt;code class=&quot;prettyprint&quot;&gt;-&gt;&gt;&lt;/code&gt;で適用する場合には逆順に処理されるので注意してください。&lt;/p&gt;&lt;pre class=&quot;prettyprint lang-clj&quot;&gt;(wrap-A (wrap-B (wrap-C app))) ; A-&amp;gt;B-&amp;gt;Cの順で処理される
(-&amp;gt; app wrap-A wrap-B wrap-C)  ; C-&amp;gt;B-&amp;gt;Aの順で処理される
(-&amp;gt; app wrap-params wrap-keyword-params) ; NG: paramsの前にkeyword-paramsが処理される
(-&amp;gt; app wrap-keyword-params wrap-params) ; OK: paramsのあとにkeyword-paramsが処理される&lt;/pre&gt;&lt;h3 id=&quot;G__2119&quot;&gt;&lt;span&gt;面&lt;/span&gt;倒くさい&lt;a class=&quot;dagger&quot; href=&quot;#G__2119&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h3&gt;&lt;p class=&quot;paragraph&quot;&gt;route毎にどのmiddlewareをラップすれば良いのかわからない！面倒くさい！
   という人用に(?)、Compojureでは&lt;code class=&quot;prettyprint&quot;&gt;site&lt;/code&gt;、&lt;code class=&quot;prettyprint&quot;&gt;api&lt;/code&gt;を用意しています。&lt;/p&gt;&lt;h4 id=&quot;G__2120&quot;&gt;&lt;span&gt;c&lt;/span&gt;ompojure.handler/site&lt;a class=&quot;dagger&quot; href=&quot;#G__2120&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h4&gt;&lt;p class=&quot;paragraph&quot;&gt;HTMLを出力するroute向け。以下7つをラップ&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;wrap-session&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;wrap-flash&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;wrap-cookies&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;wrap-multipart-params&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;wrap-params&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;wrap-nested-params&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;wrap-keyword-params&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 id=&quot;G__2121&quot;&gt;&lt;span&gt;c&lt;/span&gt;ompojure.handler/api&lt;a class=&quot;dagger&quot; href=&quot;#G__2121&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h4&gt;&lt;p class=&quot;paragraph&quot;&gt;ウェブAPI向け。以下3つをラップ&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;wrap-params&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;wrap-nested-params&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;wrap-keyword-params&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 id=&quot;G__2122&quot;&gt;&lt;span&gt;テ&lt;/span&gt;ストする&lt;a class=&quot;dagger&quot; href=&quot;#G__2122&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h2&gt;&lt;p class=&quot;paragraph&quot;&gt;ここまでに紹介したmiddlewareを使えば一般的なウェブアプリであれば
    問題なく開発できるかと思います。&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;最後にテストです。例えば以下のようなAPIのテストを書いてみましょう。&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;project.clj の dependencies に以下を追加&lt;/p&gt;&lt;pre class=&quot;prettyprint lang-clj&quot;&gt;[org.clojure/data.json &amp;quot;0.1.1&amp;quot;]&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;src/helloworld/core.clj&lt;/p&gt;&lt;pre class=&quot;prettyprint lang-clj&quot;&gt;(ns helloworld.core
  (:use
    ..省略..
    [compojure.handler :only [api]]
    [clojure.data.json :only [json-str]]))

(defn word-count [text]
  (-&amp;gt;&amp;gt; text (re-seq #&amp;quot;\w+&amp;quot;) (map (fn [x] {x 1})) (apply (partial merge-with +))))

(defroutes api-route
  (GET &amp;quot;/wc&amp;quot; { {:keys [text]} :params}
    (json-str (word-count text))))

(defroutes app
  (api api-route))&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;HTMLを返すルートのテストは難しいですが、APIでデータを返すルートのテストは&lt;code class=&quot;prettyprint&quot;&gt;ring-mock&lt;/code&gt; を使うことで簡単に記述することができます。&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;project.clj の dev-dependencies に以下を追加&lt;/p&gt;&lt;pre class=&quot;prettyprint lang-clj&quot;&gt;[ring-mock &amp;quot;0.1.1&amp;quot;]&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;test/helloworld/test/core.clj&lt;/p&gt;&lt;pre class=&quot;prettyprint lang-clj&quot;&gt;(ns helloworld.test.core
  (:use
    helloworld.core
    clojure.test
    [clojure.data.json :only [read-json]]
    [ring.mock.request :only [request]]))

(deftest word-count-test
  (let [; ring.mock.request/request でレスポンスを取得
        ; 第3引数のマップはQueryStringに展開される
        res (app (request :get &amp;quot;/wc&amp;quot; {:text &amp;quot;hello world hello&amp;quot;}))
        ; JSON形式からマップに変換
        body (-&amp;gt; res :body read-json)]
    ; are って便利
    (are [x y] (= x y)
      200 (:status res)
      2 (:hello body)
      1 (:world body))))&lt;/pre&gt;&lt;pre class=&quot;prettyprint&quot;&gt;$ lein deps
$ lein test
Testing helloworld.test.core
Ran 1 tests containing 3 assertions.
0 failures, 0 errors.&lt;/pre&gt;&lt;p class=&quot;paragraph&quot;&gt;このような感じで &lt;code class=&quot;prettyprint&quot;&gt;ring-mock&lt;/code&gt; を使うと関数のテストだけではカバーできない
   実際にリクエストで得られる結果もテストできます。&lt;/p&gt;&lt;h2 id=&quot;G__2123&quot;&gt;&lt;span&gt;最&lt;/span&gt;後に&lt;a class=&quot;dagger&quot; href=&quot;#G__2123&quot;&gt;&amp;dagger;&lt;/a&gt;&lt;/h2&gt;&lt;p class=&quot;paragraph&quot;&gt;長文になってしまいましたがいかがでしたでしょうか？
    少しでも Compojure でのウェブアプリ開発に役立てれば幸いです。&lt;/p&gt;&lt;p class=&quot;paragraph&quot;&gt;具体的なコード例は以下にコミットしてあります。
    (middlewareまわりは面倒だったので書いてないです。もし要望があれば書きます)&lt;/p&gt;&lt;a href=&quot;https://github.com/liquidz/practical-compojure-sample&quot;&gt;https://github.com/liquidz/practical-compojure-sample&lt;/a&gt;&lt;p class=&quot;paragraph&quot;&gt;なお間違いや、より良い方法などあればご指摘ください！&lt;/p&gt;</content></entry></feed>
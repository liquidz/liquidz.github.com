<!DOCTYPE html>
<html lang="ja"><head><meta charset="UTF-8"><meta content="http://liquidz.github.com/img/site_image.png" property="og:image"><meta content="http://liquidz.github.com/img/site_image.png" property="image_src"><link href="/atom.xml" rel="alternate" title="「Java使いをScalaに引き込むサンプル集」をclojureで書いてみた" type="application/atom-xml"><title>「Java使いをScalaに引き込むサンプル集」をclojureで書いてみた</title><link href="http://fonts.googleapis.com/css?family=Inconsolata" rel="stylesheet" type="text/css"><link href="/css/prettify.css" rel="stylesheet" type="text/css"><link href="/css/sunburst.css" rel="stylesheet" type="text/css"><link href="/css/main.css" rel="stylesheet" type="text/css"></head><body id="top"><a href="https://github.com/liquidz/"><img alt="Fork me on GitHub" src="https://a248.e.akamai.net/assets.github.com/img/e6bef7a091f5f3138b8cd40bc3e114258dd68ddf/687474703a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f7265645f6161303030302e706e67" style="position: absolute; top: 0; right: 0; border: 0;"></a><div class="wrapper"><header><h1><a href="/">(<span>code</span> <span class="string"><span class="double-quote">"</span>liquidz.uo<span class="double-quote">"</span></span>)</a></h1></header><div class="container"><article><div class="page-header"><h1><span>「</span>Java使いをScalaに引き込むサンプル集」をclojureで書いてみた</h1><p>14 Feb 2011</p></div><div class="post"><p class="paragraph">元ネタは以下なので、先に参照しておくとわかりやすいと思います。</p><blockquote><p>Java使いをScalaに引き込むサンプル集</p><p><a href="http://www.mwsoft.jp/programming/scala/java_to_scala.html">http://www.mwsoft.jp/programming/scala/java_to_scala.html</a></p></blockquote><p class="paragraph">同じJVM上で動く言語としてClojureだってあるんだよというのを
   知らしめたくて書いてみました。
   なおここで示すClojureコードの例はあくまで個人的な書き方なので必ずしも正しい、効率的ではないのでおかしな点があればコメントください。
   使ってるバージョンは Clojure 1.2.0 です。</p><hr><h2><span>C</span>lojureだってだいたいJavaと同じよu...ゴメンなさい嘘です</h2><p class="paragraph">ClojureもJavaの機能をそのまま使うことができます。
   以下はFileReaderを使った例。</p><pre class="prettyprint lang-clj">(import '[java.io File FileReader BufferedReader])
(let [reader (BufferedReader. (FileReader. (File. "temp.txt")))]
 (try
  (doseq [line (take-while (comp not nil?) (repeatedly #(.readLine reader)))]
   (println line))
  (finally (.close reader))))</pre><p class="paragraph">Scalaと違ってJava使いに馴染みやすい記述とは言えないものになっています。
   ちなみに with-open マクロを使うと close が不要になります。</p><pre class="prettyprint lang-clj">(with-open [reader (BufferedReader. (FileReader. (File. "temp.txt")))]
 (doseq [line (take-while (comp not nil?) (repeatedly #(.readLine reader)))]
  (println line)))</pre><p class="paragraph">あとちょっと脱線しますが、 clojure.contrib.io/read-lines を使うともっと楽です。</p><pre class="prettyprint lang-clj">(use '[clojure.contrib.io :only [read-lines]])
(doseq [line (read-lines "temp.txt")]
 (println line))</pre><hr><h2><span>初</span>期化での折り返しは不要ですよ</h2><p class="paragraph">Java, Scalaは元記事のとおり。</p><h3><span>J</span>ava</h3><pre class="prettyprint">DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
DocumentBuilder builder = factory.newDocumentBuilder();
Document doc = builder.parse(new File("foo.xml"));</pre><h3><span>S</span>cala</h3><pre class="prettyprint">val factory = DocumentBuilderFactory.newInstance();
val builder = factory.newDocumentBuilder();
val doc = builder.parse(new File("foo.xml"));</pre><p class="paragraph">Clojureだと以下です。この状況でdefを使うのは変なのでlet使ってます。</p><pre class="prettyprint lang-clj">(let [factory (DocumentBuilderFactory/newInstance)
      builder (.newDocumentBuilder factory)
      doc (.parse builder (File. "foo.xml"))]
  (do something))</pre><p class="paragraph">factory, builder を束縛する必要がないなら <code class="prettyprint">..</code> を使って以下のようにも書けます。</p><pre class="prettyprint lang-clj">(let [doc (.. (DocumentBuilderFactory/newInstance) (newDocumentBuilder) (parse (File. "foo.xml")))]
  (do something))</pre><p class="paragraph">言語の説明記事じゃないので<code class="prettyprint">..</code>の詳細は省きますが、Clojureなら1つ1つ束縛しなくても書けます。
なお Scala にある 別名import はClojureにはありません。(ドキュメントを見る限り)</p><hr><h2><span>L</span>istや配列の初期化はClojureでは問題なし</h2><p class="paragraph">リストの扱い易さはLisp方言であるClojureの強み。
   Common Lisp, Scheme同様に以下で出来ます。</p><pre class="prettyprint lang-clj">(def ls '("abc" "def" "ghi"))</pre><p class="paragraph">またClojureにはリストの他にベクターもあります。</p><pre class="prettyprint lang-clj">(def v ["abc" "def" "ghi"])</pre><p class="paragraph">ベクターはベクター用の操作関数を利用することで、リストよりも効率よく操作できたりします。</p><hr><h2><span>デ</span>フォルト引数、あるよ</h2><p class="paragraph">元記事にある foo を参考にします。</p><h3><span>S</span>cala</h3><pre class="prettyprint">def foo(c1 : Char = 'A', c2 : Char = 'B', c3 : Char = 'C') {
    println(c1.toString + c2.toString + c3.toString)
}</pre><p class="paragraph">Clojureのcoreだけ使うと以下のようになります。</p><pre class="prettyprint lang-clj">(defn foo [& {:keys [c1 c2 c3] :or {c1 "A", c2 "B", c3 "C"}}]
  (println (str c1 c2 c3)))
(foo) ; => ABC
(foo :c1 "D") ; => DBC
(foo :c2 "E" :c3 "F") ; => AEF</pre><p class="paragraph">1つの引数の場合でも名前を指定しないといけないところがScalaとの違いです。
また <code class="prettyprint">keys</code> や <code class="prettyprint">or</code> でゴチャゴチャしてます。
ここは <code class="prettyprint">clojure.contrib.def/defnk</code> を使うと見やすくなります。</p><pre class="prettyprint lang-clj">(use '[clojure.contrib.def :only [defnk]])
(defnk foo2 [:c1 "A" :c2 "B" :c3 "C"]
  (println (str c1 c2 c3)))</pre><hr><h2><span>t</span>hrows はClojureだって省略できるよ</h2><p class="paragraph">こんな感じで書いても大丈夫です。Clojureも例外処理は書かなくて良いようにできています。</p><pre class="prettyprint lang-clj">(defn get-connection []
  (DriverManager/getConnection "jdbc:sqlite:hoge.sqlite3"))</pre><hr><h2><span>文</span>字列の比較は罠になりません</h2><p class="paragraph">元記事にあった以下の比較</p><h3><span>J</span>ava</h3><pre class="prettyprint">String str1 = "テスト";
String str2 = "テスト";
String str3 = new String("テスト");
System.out.println(str1 + " == " + str2 + " = " + (str1 == str2));
  //=> テスト == テスト = true
System.out.println(str1 + " == " + str3 + " = " + (str1 == str3));
  //=> テスト == テスト = false</pre><p class="paragraph">ClojureでもScala同様に値で比較を行います。</p><pre class="prettyprint lang-clj">(let [str1 "test"
      str2 "test"
      str3 (String. "test")]
  (println str1 "=" str2 "=" (= str1 str2)) ; => true
  (println str1 "=" str3 "=" (= str1 str3))) ; => true</pre><p class="paragraph">オブジェクトの比較を行う場合は <code class="prettyprint">identical?</code> が使えます。</p><pre class="prettyprint lang-clj">(println str1 "identical?" str2 "=" (identical? str1 str2))
(println str1 "identical?" str3 "=" (identical? str1 str3))</pre><hr><h2><span>C</span>lojureもいろいろ省略できます</h2><p class="paragraph">元記事のJavaは以下。</p><h3><span>J</span>ava</h3><pre class="prettyprint">public int sum(int i1, int i2)  {
    return i1 + i2;
}</pre><p class="paragraph">素直に書いても型、returnが省略されます。</p><pre class="prettyprint lang-clj">(defn sum [i1 i2] (+ i1 i2))</pre><p class="paragraph">無名関数を使うと引き数名も省略できます。</p><pre class="prettyprint lang-clj">(def sum #(+ % %2))</pre><hr><h2><span>t</span>ry-catchの共通化だって</h2><p class="paragraph">マクロ使えばできます。
   ちなみにここでいうマクロはC言語にあるようなマクロやエクセルマクロとはまったくの別物です。</p><pre class="prettyprint lang-clj">(defmacro trycatch [& body] `(try ~@body (catch Exception e# nil)))
(println (trycatch (/ 10 3))) ; => 10/3 Clojureでは分数になります
(println (trycatch (/ 10 0))) ; => nil</pre><p class="paragraph">最初の例で使った <code class="prettyprint">with-open</code> も同様に close するという処理を共通化したマクロです。</p><hr><h2><span>ル</span>ープの入れ子も楽々</h2><p class="paragraph">元記事の以下のループ</p><h4>Java</h4><pre class="prettyprint">for (int i = 1; i > 10; i++)
    for (int j = 1; j > 10; j++)
        System.out.println(i * j);</pre><p class="paragraph">Scalaのforみたく、Clojureのforでもできます。</p><pre class="prettyprint lang-clj">(doseq [x (for [i (range 1 10), j (range 1 10)] (* i j))]
  (println x))</pre><p class="paragraph">ただClojureのforは他言語のforと違ってリストを返す関数なので
   <code class="prettyprint">doseq</code> でループして出力してあげてます。
   またScala同様に入れ子はいくつでも可能です。</p><pre class="prettyprint lang-clj">(doseq [x (for [i (range 1 4), j (range 1 4), k (range 1 4), l (range 1 4)] (* i j k l))]
  (println x))</pre><p class="paragraph">またfor内での条件も同様</p><pre class="prettyprint lang-clj">(doseq [x (for [i (range 1 10), j (range 1 10) :when (or (even? i) (even? j))] (* i j))]
  (println x))</pre><p class="paragraph">リストへの変換はもともとリストを返してるのでもちろんできます。</p><hr><h2><span>リ</span>スト操作なら任せろ</h2><p class="paragraph">ClojureはLisp方言の1つなのでリスト操作はもちろん得意</p><pre class="prettyprint lang-clj">(let [ls '(1 2 3 5 3 5 7 8)]
  ; ユニーク
  (println (distinct ls))
  ; 偶数奇数でのグループ分け
  (println (group-by odd? ls))
  ; 和
  (println (apply + ls))
  ; 積
  (println (apply * ls))
  ; それぞれ2倍したリスト
  (println (map #(* % 2) ls)))</pre><p class="paragraph">2つのリストの差分は core で上手い方法が見つからなかった。。
   とりあえずセットを使うと以下のように書けます。</p><pre class="prettyprint lang-clj">(use '[clojure.set :only [difference]])
(println (difference (hash-set 1 2 3 4 5) (hash-set 1 4 5)))</pre><p class="paragraph">またClojureでもScala同様にArrayListなどは扱うことができます。</p><pre class="prettyprint lang-clj">(import '[java.util ArrayList])
(let [ls (ArrayList.)]
  (doto ls (.add 1) (.add 2) (.add 3))
  (println (apply + ls))
  (println (map #(str "x=" %) ls)))</pre><hr><h2><span>あ</span>とがき</h2><p class="paragraph">ぜんぜんたいしたコードではないですが、ClojureでもScala並に短く書けることはわかってもらえたと思います。
   見た目のわかりやすさといった点では括弧が大きな壁にはなると思いますが、
   まぁこんな言語もあるんだよというのが伝われば幸いかなぁと思います。</p></div><div id="tweet_button"><a class="twitter-share-button" data-count="horizontal" data-lang="ja" href="https://twitter.com/share">ツイート</a><script src="//platform.twitter.com/widgets.js" type="text/javascript"></script></div><p class="gotop"><a href="#top">&raquo; Go page top</a></p></article><script src="http://embedtweet.com/javascripts/embed_v2.js" type="text/javascript"></script></div><footer><p class="copy"><a href="/">Top</a>&nbsp;|&nbsp;<a href="/archives.html">Archives</a>&nbsp;|&nbsp;<a href="http://twitter.com/uochan">@uochan</a>&nbsp;2012</p><span>generated by </span><a href="https://github.com/liquidz/misaki"><img alt="misaki" src="/img/misaki_banner.png"></a></footer></div><script src="/js/prettify.js" type="text/javascript"></script><script src="/js/lang-clj.js" type="text/javascript"></script><script src="/js/jquery-1.7.1.min.js" type="text/javascript"></script><script src="/js/jquery-contained-sticky-scroll-min.js" type="text/javascript"></script><script src="/js/coderwall.js" type="text/javascript"></script><script src="/js/main.js" type="text/javascript"></script></body></html>